
<!-- saved from url=(0106)https://moodle.bgu.ac.il/moodle/pluginfile.php/4400685/mod_resource/content/14/LabCassignment.html?embed=1 -->
<html data-darkreader-mode="dynamic" data-darkreader-scheme="dark"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><style class="darkreader darkreader--fallback" media="screen"></style><style class="darkreader darkreader--text" media="screen"></style><style class="darkreader darkreader--invert" media="screen">.jfk-bubble.gtx-bubble, .captcheck_answer_label > input + img, span#closed_text > img[src^="https://www.gstatic.com/images/branding/googlelogo"], span[data-href^="https://www.hcaptcha.com/"] > #icon, ::-webkit-calendar-picker-indicator, img.Wirisformula {
    filter: invert(100%) hue-rotate(180deg) contrast(90%) !important;
}</style><style class="darkreader darkreader--inline" media="screen">[data-darkreader-inline-bgcolor] {
  background-color: var(--darkreader-inline-bgcolor) !important;
}
[data-darkreader-inline-bgimage] {
  background-image: var(--darkreader-inline-bgimage) !important;
}
[data-darkreader-inline-border] {
  border-color: var(--darkreader-inline-border) !important;
}
[data-darkreader-inline-border-bottom] {
  border-bottom-color: var(--darkreader-inline-border-bottom) !important;
}
[data-darkreader-inline-border-left] {
  border-left-color: var(--darkreader-inline-border-left) !important;
}
[data-darkreader-inline-border-right] {
  border-right-color: var(--darkreader-inline-border-right) !important;
}
[data-darkreader-inline-border-top] {
  border-top-color: var(--darkreader-inline-border-top) !important;
}
[data-darkreader-inline-boxshadow] {
  box-shadow: var(--darkreader-inline-boxshadow) !important;
}
[data-darkreader-inline-color] {
  color: var(--darkreader-inline-color) !important;
}
[data-darkreader-inline-fill] {
  fill: var(--darkreader-inline-fill) !important;
}
[data-darkreader-inline-stroke] {
  stroke: var(--darkreader-inline-stroke) !important;
}
[data-darkreader-inline-outline] {
  outline-color: var(--darkreader-inline-outline) !important;
}
[data-darkreader-inline-stopcolor] {
  stop-color: var(--darkreader-inline-stopcolor) !important;
}
[data-darkreader-inline-bg] {
  background: var(--darkreader-inline-bg) !important;
}
[data-darkreader-inline-invert] {
    filter: invert(100%) hue-rotate(180deg);
}</style><style class="darkreader darkreader--variables" media="screen">:root {
   --darkreader-neutral-background: #131516;
   --darkreader-neutral-text: #d8d4cf;
   --darkreader-selection-background: #004daa;
   --darkreader-selection-text: #e8e6e3;
}</style><style class="darkreader darkreader--root-vars" media="screen"></style><style class="darkreader darkreader--user-agent" media="screen">@layer {
html {
    background-color: #181a1b !important;
}
html {
    color-scheme: dark !important;
}
iframe {
    color-scheme: initial;
}
html, body {
    background-color: #181a1b;
}
html, body {
    border-color: #736b5e;
    color: #e8e6e3;
}
a {
    color: #3391ff;
}
table {
    border-color: #545b5e;
}
mark {
    color: #e8e6e3;
}
::placeholder {
    color: #b2aba1;
}
input:-webkit-autofill,
textarea:-webkit-autofill,
select:-webkit-autofill {
    background-color: #404400 !important;
    color: #e8e6e3 !important;
}
::-webkit-scrollbar {
    background-color: #202324;
    color: #aba499;
}
::-webkit-scrollbar-thumb {
    background-color: #454a4d;
}
::-webkit-scrollbar-thumb:hover {
    background-color: #575e62;
}
::-webkit-scrollbar-thumb:active {
    background-color: #484e51;
}
::-webkit-scrollbar-corner {
    background-color: #181a1b;
}
::selection {
    background-color: #004daa !important;
    color: #e8e6e3 !important;
}
::-moz-selection {
    background-color: #004daa !important;
    color: #e8e6e3 !important;
}
}</style><meta name="darkreader" content="1d72ec1f55074e2faba638972c306163"><style class="darkreader darkreader--override" media="screen">.vimvixen-hint {
    background-color: #7b5300 !important;
    border-color: #d8b013 !important;
    color: #f3e8c8 !important;
}
#vimvixen-console-frame {
    color-scheme: light !important;
}
::placeholder {
    opacity: 0.5 !important;
}
#edge-translate-panel-body,
.MuiTypography-body1,
.nfe-quote-text {
    color: var(--darkreader-neutral-text) !important;
}
gr-main-header {
    background-color: #0f3a48 !important;
}
.tou-z65h9k,
.tou-mignzq,
.tou-1b6i2ox,
.tou-lnqlqk {
    background-color: var(--darkreader-neutral-background) !important;
}
.tou-75mvi {
    background-color: #032029 !important;
}
.tou-ta9e87,
.tou-1w3fhi0,
.tou-1b8t2us,
.tou-py7lfi,
.tou-1lpmd9d,
.tou-1frrtv8,
.tou-17ezmgn {
    background-color: #0a0a0a !important;
}
.tou-uknfeu {
    background-color: #231603 !important;
}
.tou-6i3zyv {
    background-color: #19576c !important;
}
div.mermaid-viewer-control-panel .btn {
    background-color: var(--darkreader-neutral-background);
    fill: var(--darkreader-neutral-text);
}
svg g rect.er {
    fill: var(--darkreader-neutral-background) !important;
}
svg g rect.er.entityBox {
    fill: var(--darkreader-neutral-background) !important;
}
svg g rect.er.attributeBoxOdd {
    fill: var(--darkreader-neutral-background) !important;
}
svg g rect.er.attributeBoxEven {
    fill: var(--darkreader-selection-background);
    fill-opacity: 0.8 !important;
}
svg rect.er.relationshipLabelBox {
    fill: var(--darkreader-neutral-background) !important;
}
svg g g.nodes rect,
svg g g.nodes polygon {
    fill: var(--darkreader-neutral-background) !important;
}
svg g rect.task {
    fill: var(--darkreader-selection-background) !important;
}
svg line.messageLine0,
svg line.messageLine1 {
    stroke: var(--darkreader-neutral-text) !important;
}
div.mermaid .actor {
    fill: var(--darkreader-neutral-background) !important;
}
.google-material-icons {
    font-family: 'Google Material Icons' !important;
}
.google-symbols {
    font-family: 'Google Symbols Subset', 'Google Symbols' !important;
}
.material-icons-extended {
    font-family: 'Material Icons Extended' !important;
}
mitid-authenticators-code-app > .code-app-container {
    background-color: white !important;
    padding-top: 1rem;
}
iframe#unpaywall[src$="unpaywall.html"] {
    color-scheme: light !important;
}
.oui-icon {
    font-family: 'Oui Icons' !important;
}</style></head><body><h2 style="text-align: left;"><span style="text-decoration: underline;"><strong>Lab C</strong></span></h2>
<p>Lab C builds on top of the code infrastructure of the "shell" from lab 2. Naturally, you are expected to
 use the code you wrote for lab 2 in this lab, and extend it. This do-at-home lab may be done in pairs.</p>
<h3><span style="text-decoration: underline;"><strong>Motivation</strong></span></h3>
<p>In this lab you will enrich the set of capabilities of your shell by adding job control, pipes, and history.
Note that all parts below, except for part 1, are features that should be added to your shell as one program
(in however many C functions you wish), that supports all these features.

</p><p><span style="text-decoration: underline;"><strong>Part 0: preparation</strong></span></p>
<p><strong>History</strong></p>

<p>Check out the "history" mechanism in the Linux shell.
For example, see <a href="https://opensource.com/article/18/6/history-command">this link</a> and try it out in a Linux shell.</p><p>

</p><p>Reexamine your command interpreter (shell) code from lab 2, 
and if not done so before, reorganize it to be as modular and extensible as possible,</p>

<h1><span style="text-decoration: underline;"><strong>Lab C Parts</strong></span></h1>

<h2><strong>Part 1: An Exercise in Pipes</strong></h2>

<p><strong>Note</strong><br> This part is independent of the shell, and a preparation for
implementing a pipe command in the shell. You should not  
use the LineParser functions in this task, nor read any command lines.
However, you need to declare an array of "strings" containing 
all of the arguments and ending with 0 to pass to execvp() just like the one returned by parseCmdLines().</p>
<p><br> Here we wish to explore the implementation of a pipeline. In order to achieve such a pipeline, one has to 
create a pipe and properly redirect the standard output and standard input of processes.<br> Please refer to the 
'Introduction to Pipelines' section in the reading material.<br> <br> <strong>Your task:</strong>&nbsp;Write a short
program called&nbsp;<strong>mypipeline</strong>&nbsp;which creates a pipeline of 2 child processes. 
Essentially, you will implement the shell command line&nbsp;<strong>"ls -l | tail -n 2"</strong>.<br> 
(A question:&nbsp;what does "ls -l" do, what does "tail -n 2" do, and what should 
their combination produce?)<br> <br> <strong>Follow the given steps as closely as possible to avoid synchronization problems:</strong></p>
<ol>
<li>Create a pipe.</li>
<li>Fork a first child process (child1).</li>
<li>In the child1 process:</li>
<ol>
<li>Close the standard output.</li>
<li>Duplicate the write-end of the pipe using&nbsp;<strong>dup</strong>&nbsp;(see man).</li>
<li>Close the file descriptor that was duplicated.</li>
<li>Execute "ls -l".</li>
</ol>
<li><strong>In the parent process: Close the write end of the pipe.</strong></li>
<li>Fork a second child process (child2).</li>
<li>In the child2 process:</li>
<ol>
<li>Close the standard input.</li>
<li>Duplicate the read-end of the pipe using&nbsp;<strong>dup</strong>.</li>
<li>Close the file descriptor that was duplicated.</li>
<li>Execute "tail -n 2".</li>
</ol>
<li><strong>In the parent process: Close the read end of the pipe.</strong></li>
<li>Now wait for the child processes to terminate, in the same order of their execution.</li>
</ol>

<p>After implementing the above code, debug and test it as follows:
Compile and run the code and make sure it does what it is supposed to do,
by adding debug messages printed to stderr as follows:</p>

<ul>
<ul>
<li>In the parent process:</li>
<ul>
<li>Before forking, "(parent_process&gt;forking…)"</li>
<li>After forking, "(parent_process&gt;created process with id:&nbsp;)"</li>
<li>Before closing the write end of the pipe, "(parent_process&gt;closing the write end of the pipe…)"</li>
<li>Before closing the read end of the pipe, "(parent_process&gt;closing the read end of the pipe…)"</li>
<li>Before waiting for child processes to terminate, "(parent_process&gt;waiting for child processes to terminate…)"</li>
<li>Before exiting, "(parent_process&gt;exiting…)"</li>
</ul>
<li>In the 1st child process:</li>
<ul>
<li>"(child1&gt;redirecting stdout to the write end of the pipe…)"</li>
<li>"(child1&gt;going to execute cmd:&nbsp;…)"</li>
</ul>
<li>In the 2nd child process:</li>
<ul>
<li>"(child2&gt;redirecting stdin to the read end of the pipe…)"</li>
<li>"(child2&gt;going to execute cmd:&nbsp;…)"</li>
</ul>
</ul>
</ul>
<ol start="3">
<li>How does the following affect your program:</li>
<ol>
<li>Comment out step 4 in your code (i.e. on the parent process:<strong>do not</strong>&nbsp;Close the write end of the pipe). 
Compile and run your code. (Also: see "man 7 pipe")</li>
<li>Undo the change from the last step. Comment out step 7 in your code. Compile and run your code.</li>
<li>Undo the change from the last step. Comment out step 4 and step 8 in your code. Compile and run your code.</li>
</ol>
</ol>
<p>&nbsp;</p>

<h2><strong>Part 2: Implementing a Pipe in the Shell</strong></h2>

<p>Having learned how to create a pipe between 2 processes/programs in Part 1, we now wish to implement a pipeline 
<b>inside</b> our own shell.
In this part you will extend your shell's capabilities to support pipelines that consist of just one pipe and 2 child processes.
That is, support a command line with one pipe between 2 processes resulting from running executable files mentioned in the command line.
The scheme uses basically the same mechanism as in part 1, except that now the program to be executed in each child process
is determined by the command line.
</p>

Your shell must be able now to run commands 
like:&nbsp;ls|wc -l&nbsp;which basically counts the number of files/directories under the current working dir. 
The most important thing to remember about pipes is that the write-end of the pipe needs to be closed in all processes, 
otherwise the read-end of the pipe will not receive EOF, unless the main process terminates.<p></p>

<p>Notes:</p>
<ul>
<li>The line parser automatically generates a list of cmdLine structures to accommodate pipelines. For instance, when parsing
 the command&nbsp;<strong>"ls | grep .c"</strong>, two chained cmdLine structures are created, 
 representing&nbsp;<strong>ls</strong>&nbsp;and&nbsp;<strong>grep</strong>&nbsp;respectively.</li>
<li>Your shell must still support all previous features, including input/output redirection from lab 2. Obviously,
it makes no sense to redirect the output of the left--hand-side process (as then nothing goes into the pipe), and
this should be considered an error, and likewise redirecting the input of the right-hand-side process is an error (as then
the pipe output is hanging). In such cases, print an error message to stderr without generating any new processes.
It is important to note that commands utilizing both I/O redirection and pipelines are indeed quite common 
(e.g.&nbsp;<strong>"cat &lt; in.txt | tail -n 2 &gt; out.txt"</strong>).</li>
<li>As in previous tasks, you must keep your program free of memory leaks.</li>
</ul>



<h2> Part 3: Process Manager</h2>
    Every program you run using the shell runs as a process. You can get a list of the running processes using the <code class="code">ps</code> program
    (see: <code class="code">man 1 ps</code> and <code class="code">man 2 ps</code>).
    
    In this task we are going to add to your shell an internal "process manager" to manage the process we run in our shell 
	(everything you fork). 
    The process manager will provide 4 operations:
    <ul>
    <li> <code class="code">procs</code> - prints current processes including sleeping, running, and "freshly" terminated processes. 
    </li><li> <code class="code">wake &lt;process id&gt; </code> - wakes up a sleeping process.
    </li><li> <code class="code">suspend &lt;process id&gt;</code> - suspends a running process.
    </li><li> <code class="code">kill &lt;process id&gt;</code> - terminates a running/sleeping process (was implemented in lab 2).
    </li></ul>
    <br>
    
    <h3 id="task_1a_-_process_list">Part 3a - Process List</h3>
    In this part we will create and print a list of all processes that have been forked by your shell. <br>
    <!--?}?-->
    
    <h4>Representation</h4>
    Create a linked list to store information about running/suspended processes. Each node in the list is a struct process:
    <p></p><p>
    </p><pre class="code">    typedef struct process{
        cmdLine* cmd;                         /* the parsed command line*/
        pid_t pid; 		                  /* the process id that is running the command*/
        int status;                           /* status of the process: RUNNING/SUSPENDED/TERMINATED */
        struct process *next;	                  /* next process in chain */
    } process;
    </pre>
    
    <p></p><p>
    The field <i>status</i> can have one of the following values:
    </p><p>
    </p><pre class="code">    #define TERMINATED  -1
    #define RUNNING 1
    #define SUSPENDED 0
    </pre>
    
    <h4>Implementation</h4>
    Implement the following functions that create and print the process list:
    <ul>
    <li> <code class="code">void addProcess(process** process_list, cmdLine* cmd, pid_t pid);</code>: Receive a process list
	(process_list), a command (cmd), and the process id (pid) of the process running the command. Note that process_list is a pointer to a pointer so that we can insert at the beginning of the list if we wish.
    </li><li> <code class="code">void printProcessList(process** process_list);</code>: print the processes. 
    </li><li> Add support for the command <code class="code">procs</code> to the shell which prints processes 
	using printProcessList()in the following format: <br>
    <code class="code">&lt;index in process list&gt; &lt;process id&gt; &lt;process status&gt; &lt;the command 
	together with its arguments&gt;</code>  
    </li></ul>
    Example:<br>
    <pre class="code">    #&gt; sleep 3  # foreground, takes 3 seconds until we get prompt back
    #&gt; procs
    PID          Command      STATUS
    14952        sleep        Terminated
    #&gt; 
    #&gt; sleep 5&amp; # background, we get prompt back immediately
    #&gt; procs
    PID          Command      STATUS
    14962        sleep        Running
    #&gt; # Wait for the process to finish
    #&gt; 
    #&gt; procs
    PID          Command      STATUS
    14962        sleep        Terminated
    </pre>
    <p></p>
    
    <h2 id="task_1b_-_updating_the_process_list">Part 3b - Updating the Process List</h2>
    Implement the following to add some functionality to your process list:
    <ul>
    <li> <code class="code">void freeProcessList(process* process_list);</code>: free all memory allocated for the process list.
    </li><li> <code class="code">void updateProcessList(process **process_list);</code>:  go over the process list, and for each process check if it is done, you can use waitpid with the option WNOHANG. WNOHANG does not block the calling process, the process returns from the call to waitpid immediately. If no process with the given process id exists, then waitpid returns -1.<br>
    <b>In order to learn if a process was stopped (SIGTSTP), resumed (SIGCONT) or terminated (SIGINT), It's highly essential you read and understand how to use <u>waitpid(2)</u> before implementing this function</b>
    </li><li> <code class="code">void updateProcessStatus(process* process_list, int pid, int status)</code>: find the process with the given id in the process_list and change its status to the received status.
    </li><li> update <code class="code">void printProcessList(process** process_list);</code>: 
      <ul>
       <li> Run updateProcessList() at the beginning of the function.
       </li><li>If a process was "freshly" terminated, delete it after printing it (meaning print the list with the updated status, then delete the dead processes). 
      </li></ul>
    </li></ul>
	
    <h3 id="task_1c_-_manipulating_the_processes">Part 3c - Manipulating the Processes</h3>
    In this part you add to your shell process manipulation commands, all of the following (some you already implemented in lab 2): 
    <ul>
    <li> <code class="code">sleep &lt;process id&gt;</code> - suspends a running process. Send SIGTSTP to the respective process. This is similar to typing CTRL-Z in the shell when running the process.
    </li><li> <code class="code">blast &lt;process id&gt;</code> - terminates a running/sleeping process. Send SIGINT to the respective process. This is similar to typing CTRL-C in the shell when running a process.
    </li><li> <code class="code">alarm &lt;process id&gt; </code> - wakes up a sleeping process.  Send SIGCONT to the respective process. This is similar to typing <code class="code">fg</code> in a standard shell, right after typing CTRL-Z.
    </li></ul>
    <br>
    Use kill(), see man 2 kill, to send the relevant signal to the given process id. Check if kill() succeeded and print an appropriate message.
    Remember to update the status of the process in the process_list.<br>
    <p></p><p>
    Test your shell using your <code class="code">looper</code> code from task0b in the following scenario: 
    </p><p>
    </p><pre class="code">    #&gt; ./looper&amp;
    #&gt; ./looper&amp;
    #&gt; ./looper&amp;
    #&gt; procs
    PID         Command     STATUS
    18170       ./looper    Running
    18171       ./looper    Running
    18174       ./looper    Running
    #&gt; blast 18170
    #&gt; Looper handling SIGINT       # Message from the child process
    
    #&gt; sleep 18174
    #&gt; Looper handling SIGTSTP      # Message from the child process    
    procs
    PID         Command     STATUS
    18170       ./looper    Terminated
    18171       ./looper    Running
    18174       ./looper    Suspended
    #&gt; alarm 18174
    #&gt; Looper handling SIGCONT      # Message from the child process
    
    #&gt; alarm 18171   # What will happen to the process? (it is already running)
    #&gt; Looper handling SIGCONT      # Message from the child process
    procs
    PID         Command     STATUS
    18171       ./looper    Running
    18174       ./looper    Running
    
    </pre>
    

<h2><strong>Part 4: Adding the History Mechanism</strong></h2>

<p>Here you will add a history mechanism to your shell. The history mechanism works as follows. Your shell should keep HISTLEN 
previous command lines
in a queue, where HISTLEN is a constant with a value of 20 as a default. 
The history list is maintained in an 2 dimensional array of size HISTLEN "rows", each with MAX_BUF (200 as a default) characters, containing null terminated
(copies of) previous commands. You may wish to use strncpy here to copy a command line into the array.
Note that
you should keep the UNPARSED command lines in the history list, and NOT the parsed version.</p>
<p>
When a new command line is entered after the history list is full (already has HISTLEN entries), delete the oldest entry and insert the new one.
You should implement the history as a circular queue, using "newest" and "oldest" indices.
</p>

<p>The user can now perform the following functions as a shell command (not a process!):</p>
<ul>
<li> "history": print the history list (number of entry in the array and the appropriate command line), for all valid entries.</li>
<li> "!!": retrieve the last command line (non-history, for clarification please refer to lab reading material) CL, enter CL again into the queue, and execute it (needs to be parsed again!).
</li><li> "!n": With n a number between 1 and HISTLEN, as in "!!" except with CL being the command line at history index n.
If n is an invalid number (out of range, or no such entry yet) print an error message to stdout and ignore this command line.</li>
</ul>
<p>Note that your shell should support history on top of all the other features: pipes, redirection, etc. This should not be hard if your code is well-designed.</p>


<p><strong>Submission</strong></p>
<p>Submit a zip file (named either [student-id-num].zip [student1-id-num_student2-id-num.zip] in case of pair submission)
 with the following files: mypipeline.c that implements the stand-alone pipe from part 1, and 
myshell.c, the source code of a shell supporting all features
from lab 2 and from this lab (parts 2,3,4) and a makefile to compile and link them
into the executables "mypipeline" and "myshell", respectively.</p>

</body></html>