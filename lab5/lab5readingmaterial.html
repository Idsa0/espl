
<!-- saved from url=(0110)https://moodle.bgu.ac.il/moodle/pluginfile.php/4400722/mod_resource/content/9/lab5readingmaterial.html?embed=1 -->
<html data-darkreader-mode="dynamic" data-darkreader-scheme="dark" data-darkreader-proxy-injected="true"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><style class="darkreader darkreader--fallback" media="screen"></style><style class="darkreader darkreader--text" media="screen"></style><style class="darkreader darkreader--invert" media="screen">.jfk-bubble.gtx-bubble, .captcheck_answer_label > input + img, span#closed_text > img[src^="https://www.gstatic.com/images/branding/googlelogo"], span[data-href^="https://www.hcaptcha.com/"] > #icon, ::-webkit-calendar-picker-indicator, img.Wirisformula {
    filter: invert(100%) hue-rotate(180deg) contrast(90%) !important;
}</style><style class="darkreader darkreader--inline" media="screen">[data-darkreader-inline-bgcolor] {
  background-color: var(--darkreader-inline-bgcolor) !important;
}
[data-darkreader-inline-bgimage] {
  background-image: var(--darkreader-inline-bgimage) !important;
}
[data-darkreader-inline-border] {
  border-color: var(--darkreader-inline-border) !important;
}
[data-darkreader-inline-border-bottom] {
  border-bottom-color: var(--darkreader-inline-border-bottom) !important;
}
[data-darkreader-inline-border-left] {
  border-left-color: var(--darkreader-inline-border-left) !important;
}
[data-darkreader-inline-border-right] {
  border-right-color: var(--darkreader-inline-border-right) !important;
}
[data-darkreader-inline-border-top] {
  border-top-color: var(--darkreader-inline-border-top) !important;
}
[data-darkreader-inline-boxshadow] {
  box-shadow: var(--darkreader-inline-boxshadow) !important;
}
[data-darkreader-inline-color] {
  color: var(--darkreader-inline-color) !important;
}
[data-darkreader-inline-fill] {
  fill: var(--darkreader-inline-fill) !important;
}
[data-darkreader-inline-stroke] {
  stroke: var(--darkreader-inline-stroke) !important;
}
[data-darkreader-inline-outline] {
  outline-color: var(--darkreader-inline-outline) !important;
}
[data-darkreader-inline-stopcolor] {
  stop-color: var(--darkreader-inline-stopcolor) !important;
}
[data-darkreader-inline-bg] {
  background: var(--darkreader-inline-bg) !important;
}
[data-darkreader-inline-invert] {
    filter: invert(100%) hue-rotate(180deg);
}</style><style class="darkreader darkreader--variables" media="screen">:root {
   --darkreader-neutral-background: #131516;
   --darkreader-neutral-text: #d8d4cf;
   --darkreader-selection-background: #004daa;
   --darkreader-selection-text: #e8e6e3;
}</style><style class="darkreader darkreader--root-vars" media="screen"></style><style class="darkreader darkreader--user-agent" media="screen">@layer {
html {
    background-color: #181a1b !important;
}
html {
    color-scheme: dark !important;
}
iframe {
    color-scheme: initial;
}
html, body {
    background-color: #181a1b;
}
html, body {
    border-color: #736b5e;
    color: #e8e6e3;
}
a {
    color: #3391ff;
}
table {
    border-color: #545b5e;
}
mark {
    color: #e8e6e3;
}
::placeholder {
    color: #b2aba1;
}
input:-webkit-autofill,
textarea:-webkit-autofill,
select:-webkit-autofill {
    background-color: #404400 !important;
    color: #e8e6e3 !important;
}
::-webkit-scrollbar {
    background-color: #202324;
    color: #aba499;
}
::-webkit-scrollbar-thumb {
    background-color: #454a4d;
}
::-webkit-scrollbar-thumb:hover {
    background-color: #575e62;
}
::-webkit-scrollbar-thumb:active {
    background-color: #484e51;
}
::-webkit-scrollbar-corner {
    background-color: #181a1b;
}
::selection {
    background-color: #004daa !important;
    color: #e8e6e3 !important;
}
::-moz-selection {
    background-color: #004daa !important;
    color: #e8e6e3 !important;
}
}</style><meta name="darkreader" content="eb88b1544f5c46abbac00d9cda79878a"><style class="darkreader darkreader--override" media="screen">.vimvixen-hint {
    background-color: #7b5300 !important;
    border-color: #d8b013 !important;
    color: #f3e8c8 !important;
}
#vimvixen-console-frame {
    color-scheme: light !important;
}
::placeholder {
    opacity: 0.5 !important;
}
#edge-translate-panel-body,
.MuiTypography-body1,
.nfe-quote-text {
    color: var(--darkreader-neutral-text) !important;
}
gr-main-header {
    background-color: #0f3a48 !important;
}
.tou-z65h9k,
.tou-mignzq,
.tou-1b6i2ox,
.tou-lnqlqk {
    background-color: var(--darkreader-neutral-background) !important;
}
.tou-75mvi {
    background-color: #032029 !important;
}
.tou-ta9e87,
.tou-1w3fhi0,
.tou-1b8t2us,
.tou-py7lfi,
.tou-1lpmd9d,
.tou-1frrtv8,
.tou-17ezmgn {
    background-color: #0a0a0a !important;
}
.tou-uknfeu {
    background-color: #231603 !important;
}
.tou-6i3zyv {
    background-color: #19576c !important;
}
div.mermaid-viewer-control-panel .btn {
    background-color: var(--darkreader-neutral-background);
    fill: var(--darkreader-neutral-text);
}
svg g rect.er {
    fill: var(--darkreader-neutral-background) !important;
}
svg g rect.er.entityBox {
    fill: var(--darkreader-neutral-background) !important;
}
svg g rect.er.attributeBoxOdd {
    fill: var(--darkreader-neutral-background) !important;
}
svg g rect.er.attributeBoxEven {
    fill: var(--darkreader-selection-background);
    fill-opacity: 0.8 !important;
}
svg rect.er.relationshipLabelBox {
    fill: var(--darkreader-neutral-background) !important;
}
svg g g.nodes rect,
svg g g.nodes polygon {
    fill: var(--darkreader-neutral-background) !important;
}
svg g rect.task {
    fill: var(--darkreader-selection-background) !important;
}
svg line.messageLine0,
svg line.messageLine1 {
    stroke: var(--darkreader-neutral-text) !important;
}
div.mermaid .actor {
    fill: var(--darkreader-neutral-background) !important;
}
mitid-authenticators-code-app > .code-app-container {
    background-color: white !important;
    padding-top: 1rem;
}
iframe#unpaywall[src$="unpaywall.html"] {
    color-scheme: light !important;
}</style></head><body><h1>Lab 5 - Reading Material</h1>

<h2>Introduction</h2>
<p>
In this lab you will write your own program loader. In many cases, a program loader is used for dynamically linked executables, where some linking must be done at execution time (i.e. linking to library routines).
Normal (static) executables are loaded into memory by the operating system. Your task will be to implement your own static loader, which loads a static executable into memory and transfers 
control to it. Your loader will be able to load all your code which uses the <tt>system_call</tt> interface.
</p>

<h2>From the Specification</h2>
<p>
Program headers and static program loading are described in pages 2-1 up to 2-9 of the 
<a href="https://moodle.bgu.ac.il/moodle/pluginfile.php/3793896/mod_resource/content/1/ELF_Format_Manual.pdf">ELF file specification manual</a>.
</p><p>
Some additional information is given below.

</p><h2>Virtual Memory</h2>

<p>
Modern operating systems employ a scheme called Virtual Memory. This scheme enables each process to have its own view of memory, independent of other processes. 
The operating system (with help from the hardware) maps process memory (virtual pages) into real memory (real pages). </p>

<p>
This way, each process can pretend it is the only process running on the system, 
and trust the operating system to ensure its memory does not collide with other processes.
</p>

<h2>The Linker's Job</h2>

<p>The introduction of virtual memory makes life much easier on the compiler and linker. 
The compiler generates code which thinks it is located at the beginning of memory 
(address 0x0), and leaves information for the linker on where corrections
need be made. The linker is in charge of choosing the memory layout of the program, 
and can decide to which address in virtual memory the code will be loaded to.</p>

A simple example will help illustrate the point. Look at the following code:
<p>
<code>
char *message = "hello linker";
</code></p><p><code>
void foo(){
  <br>
    printf("%s\n",message);
    <br>
}
</code></p><code>
</code>
<p></p>

Compiling this code to produce an object file ends up looking like this: 
<a href="https://moodle.bgu.ac.il/moodle/pluginfile.php/3793911/mod_folder/content/0/object.jpg?forcedownload=1">fig1</a>

<p>
When the linker is asked to link this code, and make it an executable, it needs to decide on
the memory layout first: what will the virtual address of <tt>foo()</tt> will be, and where in
virtual memory will <tt>message</tt> be located?
</p>
<p>After deciding on the memory layout, the linker needs to inform the loader how to load the 
executable. This is done by using program headers in the ELF format.</p>

<!--(Note that the linker has many other responsibilities, some of which will be
discussed in later labs.)-->

<h2>The Static Loader</h2>

<h3>Introduction</h3>
<p>The job of the Loader is to load the executable into main memory. It does so by reading the 
program headers located in the ELF formatted executable, and acting accordingly. 
Let us take a look at the program header of an ELF file:  <br>
</p><p>
<code>
typedef struct {<br>
</code></p><p><code>
        Elf32_Word      p_type;         /* entry type */<br>
        Elf32_Off       p_offset;       /* file offset */<br>
        Elf32_Addr      p_vaddr;        /* virtual address */<br>
        Elf32_Addr      p_paddr;        /* physical address */<br>
        Elf32_Word      p_filesz;       /* file size */<br>
        Elf32_Word      p_memsz;        /* memory size */<br>
        Elf32_Word      p_flags;        /* entry flags */<br>
        Elf32_Word      p_align;        /* memory/file alignment */<br>
        </code></p><code>
} Elf32_Phdr;
</code>
<p></p>



<ul>
 <li> <tt> p_type</tt>: The type of the entry. We are only interested in PT_LOAD, which means the loader must load the appropriate data from the file into memory.</li>
 
 <li> <tt> p_offset</tt>: The offset in the file, from which we start to load data.</li>
<li> <tt> p_vaddr</tt>: The virtual address to which we load the data.</li>
<li> <tt> p_paddr</tt>: The physical address. On x86 we can safely ignore this.</li>
<li>  <tt> p_filesz</tt>: Total amount of data which need to be mapped from the file.</li>
<li>  <tt> p_memsz</tt>:  Total amount of data which needs to be mapped (can differ from <tt> p_filesz</tt>).</li>
<li>  <tt> p_flags</tt>: The flags:
<ul>
<li> PF_R: map for reading.</li>
<li> PF_w: map for writing.</li>
<li> PF_X: map for execution.</li>
</ul>
</li>

<li> <tt> p_align</tt>: The alignment needed. The linker must make sure this section's virtual address equals 0 module p_align.</li>
</ul>

<p></p>

<p>One remarks is in order: <tt> p_filesz</tt> can be different from <tt> p_memsz</tt>.
This can happen when, for example, we need to allocate space for uninitialized variables in memory. 
There is no point in wasting space in the executable file for such variables (the section which holds these variables is traditionally called the ".bss" section).


</p><h2>Implementation Issues</h2>


<h3>Loader Virtual Memory</h3>
<p>
When implementing your loader, keep in mind the loaded program will "live" in the same address 
space as the loader. 
After loading the executable, the memory should look like this:
<a href="https://moodle.bgu.ac.il/moodle/pluginfile.php/3793911/mod_folder/content/0/loaded-object.jpg?forcedownload=1">fig2</a>

<br>
Now, "normal" code produced by the standard gnu tool chain (<i>gcc</i>, <i>ld</i>, etc.) is usually mapped to virtual memory starting at address 0x08048000. 
This mean that unless some special measure is taken, both the loader and the loaded program will be mapped to the same memory space, which will result in a nasty collision. 
<br>
In order to solve this situation, we must satisfy at least one of the
following conditions: <br>

</p><ul>
<li> Your loader will be mapped to a different (lower) address.</li>
<li> The loaded program will be mapped to a different (higher) address.</li>
</ul>

In this lab we will satisfy condition (1) by asking the <i>ld</i> program to create our <i>loader</i> program so that it will get loaded into a lower address.
<p></p>

<h3>Compilation of the Loader</h3>

<p>To compile the loader, and tell the linker to map its code to the address we want, you will need to tell the linker to use a custom made linking script (you usually did not provide any script to the linker, you used the default one....). 
Furthermore, you need to use the startup.o object file, since it contains the <tt>startup</tt> function (for further details, look at task 2).
<br>
So, your command line will look something like this (note that the order is important, and that the flags from -L/usr/lib32 onwards should appear after the .o files):
</p>
<p>
on a 64-bit machine (use <i>uname -a</i> to check if your OS is 64bit or not): <br>
<code>
 gcc -m32 -c loader.c -o loader.o<br>
 ld  -o loader loader.o startup.o start.o -L/usr/lib32 -lc -T linking_script -dynamic-linker /lib32/ld-linux.so.2
</code>

</p><p>
on a 32-bit machine:<br>
<code>
 gcc -c loader.c -o loader.o<br>
 ld -o loader loader.o startup.o start.o -lc -T linking_script -dynamic-linker /lib/ld-linux.so.2
</code>

</p><h3>Mapping the Loaded Executable into Memory</h3>

When mapping the executable into memory, keep in mind the following:

<ol>
	<li>Use the following flags:
		<ul>
		<li>MAP_PRIVATE: tell the mapping not to affect the file </li>
		<li>MAP_FIXED: force the mapping to use the starting address you want</li>
		</ul>
	</li>
	<li> Memory mapping which uses MAP_FIXED can only be performed to addresses
	     congruent to PAGE_SIZE (0x1000). <br>
	     As a result, measures must be taken when mapping program headers which do not
	     obey this restriction.
	     </li>
	<li>Solution for the previous point: <br>
<code>
vaddr = phdr.p_vaddr&amp;0xfffff000;<br>
offset = phdr.p_offset&amp;0xfffff000;<br>
padding = phdr.p_vaddr &amp; 0xfff;<br>
map = mmap(vaddr, phdr.p_memsz+padding, 
           APPROPRIATE_PERMISSION_FLAGS, 
           APPROPRIATE_MAPPING_FLAGS,
           fd, offset);
</code>
	
	</li>
</ol>
</body></html>