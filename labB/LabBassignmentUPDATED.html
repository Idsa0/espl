<!DOCTYPE html>
<!-- saved from url=(0105)https://moodle.bgu.ac.il/moodle/pluginfile.php/4400665/mod_resource/content/13/LabBassignmentUPDATED.html -->
<html lang="en" data-darkreader-mode="dynamic" data-darkreader-scheme="dark"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><style class="darkreader darkreader--fallback" media="screen"></style><style class="darkreader darkreader--text" media="screen"></style><style class="darkreader darkreader--invert" media="screen">.jfk-bubble.gtx-bubble, .captcheck_answer_label > input + img, span#closed_text > img[src^="https://www.gstatic.com/images/branding/googlelogo"], span[data-href^="https://www.hcaptcha.com/"] > #icon, ::-webkit-calendar-picker-indicator, img.Wirisformula {
    filter: invert(100%) hue-rotate(180deg) contrast(90%) !important;
}</style><style class="darkreader darkreader--inline" media="screen">[data-darkreader-inline-bgcolor] {
  background-color: var(--darkreader-inline-bgcolor) !important;
}
[data-darkreader-inline-bgimage] {
  background-image: var(--darkreader-inline-bgimage) !important;
}
[data-darkreader-inline-border] {
  border-color: var(--darkreader-inline-border) !important;
}
[data-darkreader-inline-border-bottom] {
  border-bottom-color: var(--darkreader-inline-border-bottom) !important;
}
[data-darkreader-inline-border-left] {
  border-left-color: var(--darkreader-inline-border-left) !important;
}
[data-darkreader-inline-border-right] {
  border-right-color: var(--darkreader-inline-border-right) !important;
}
[data-darkreader-inline-border-top] {
  border-top-color: var(--darkreader-inline-border-top) !important;
}
[data-darkreader-inline-boxshadow] {
  box-shadow: var(--darkreader-inline-boxshadow) !important;
}
[data-darkreader-inline-color] {
  color: var(--darkreader-inline-color) !important;
}
[data-darkreader-inline-fill] {
  fill: var(--darkreader-inline-fill) !important;
}
[data-darkreader-inline-stroke] {
  stroke: var(--darkreader-inline-stroke) !important;
}
[data-darkreader-inline-outline] {
  outline-color: var(--darkreader-inline-outline) !important;
}
[data-darkreader-inline-stopcolor] {
  stop-color: var(--darkreader-inline-stopcolor) !important;
}
[data-darkreader-inline-bg] {
  background: var(--darkreader-inline-bg) !important;
}
[data-darkreader-inline-invert] {
    filter: invert(100%) hue-rotate(180deg);
}</style><style class="darkreader darkreader--variables" media="screen">:root {
   --darkreader-neutral-background: #131516;
   --darkreader-neutral-text: #d8d4cf;
   --darkreader-selection-background: #004daa;
   --darkreader-selection-text: #e8e6e3;
}</style><style class="darkreader darkreader--root-vars" media="screen"></style><style class="darkreader darkreader--user-agent" media="screen">@layer {
html {
    background-color: #181a1b !important;
}
html {
    color-scheme: dark !important;
}
iframe {
    color-scheme: initial;
}
html, body {
    background-color: #181a1b;
}
html, body {
    border-color: #736b5e;
    color: #e8e6e3;
}
a {
    color: #3391ff;
}
table {
    border-color: #545b5e;
}
mark {
    color: #e8e6e3;
}
::placeholder {
    color: #b2aba1;
}
input:-webkit-autofill,
textarea:-webkit-autofill,
select:-webkit-autofill {
    background-color: #404400 !important;
    color: #e8e6e3 !important;
}
::-webkit-scrollbar {
    background-color: #202324;
    color: #aba499;
}
::-webkit-scrollbar-thumb {
    background-color: #454a4d;
}
::-webkit-scrollbar-thumb:hover {
    background-color: #575e62;
}
::-webkit-scrollbar-thumb:active {
    background-color: #484e51;
}
::-webkit-scrollbar-corner {
    background-color: #181a1b;
}
::selection {
    background-color: #004daa !important;
    color: #e8e6e3 !important;
}
::-moz-selection {
    background-color: #004daa !important;
    color: #e8e6e3 !important;
}
}</style>
    
    <title>Title</title>
    <style>
        table {
            font-family: arial, sans-serif;
            border-collapse: collapse;
            width: 100%;
        }

        td, th {
            border: 1px solid #dddddd;
            text-align: left;
            padding: 8px;
        }
    </style><style class="darkreader darkreader--sync" media="screen"></style>
<meta name="darkreader" content="d6952335193c490d9e07f6c4eb3c17c5"><style class="darkreader darkreader--override" media="screen">.vimvixen-hint {
    background-color: #7b5300 !important;
    border-color: #d8b013 !important;
    color: #f3e8c8 !important;
}
#vimvixen-console-frame {
    color-scheme: light !important;
}
::placeholder {
    opacity: 0.5 !important;
}
#edge-translate-panel-body,
.MuiTypography-body1,
.nfe-quote-text {
    color: var(--darkreader-neutral-text) !important;
}
gr-main-header {
    background-color: #0f3a48 !important;
}
.tou-z65h9k,
.tou-mignzq,
.tou-1b6i2ox,
.tou-lnqlqk {
    background-color: var(--darkreader-neutral-background) !important;
}
.tou-75mvi {
    background-color: #032029 !important;
}
.tou-ta9e87,
.tou-1w3fhi0,
.tou-1b8t2us,
.tou-py7lfi,
.tou-1lpmd9d,
.tou-1frrtv8,
.tou-17ezmgn {
    background-color: #0a0a0a !important;
}
.tou-uknfeu {
    background-color: #231603 !important;
}
.tou-6i3zyv {
    background-color: #19576c !important;
}
div.mermaid-viewer-control-panel .btn {
    background-color: var(--darkreader-neutral-background);
    fill: var(--darkreader-neutral-text);
}
svg g rect.er {
    fill: var(--darkreader-neutral-background) !important;
}
svg g rect.er.entityBox {
    fill: var(--darkreader-neutral-background) !important;
}
svg g rect.er.attributeBoxOdd {
    fill: var(--darkreader-neutral-background) !important;
}
svg g rect.er.attributeBoxEven {
    fill: var(--darkreader-selection-background);
    fill-opacity: 0.8 !important;
}
svg rect.er.relationshipLabelBox {
    fill: var(--darkreader-neutral-background) !important;
}
svg g g.nodes rect,
svg g g.nodes polygon {
    fill: var(--darkreader-neutral-background) !important;
}
svg g rect.task {
    fill: var(--darkreader-selection-background) !important;
}
svg line.messageLine0,
svg line.messageLine1 {
    stroke: var(--darkreader-neutral-text) !important;
}
div.mermaid .actor {
    fill: var(--darkreader-neutral-background) !important;
}
.google-material-icons {
    font-family: 'Google Material Icons' !important;
}
.google-symbols {
    font-family: 'Google Symbols Subset', 'Google Symbols' !important;
}
.material-icons-extended {
    font-family: 'Material Icons Extended' !important;
}
mitid-authenticators-code-app > .code-app-container {
    background-color: white !important;
    padding-top: 1rem;
}
iframe#unpaywall[src$="unpaywall.html"] {
    color-scheme: light !important;
}
.oui-icon {
    font-family: 'Oui Icons' !important;
}</style></head>
<body>

<h1>
    C Programming: debugging, dynamic data structures: linked lists, patching binary files.
    <p> This lab assignment may be done in pairs.
</p></h1>
<h4>Home-Lab B -- Assignment goals:</h4>
<p>
</p><ul>
    <li> Pointers and dynamically allocated structures and the "Valgrind" utility</li>
    <li> Understanding data structures: linked lists in C</li>
    <li> Basic access to "binary" files, with application: simplified virus detection in executable files</li>
</ul>
<br>In this lab you are required to use Valgrind to make sure your program is "memory-leak" free.
If you use the VM we supplied you, you should install the library libc6-dbg:i386 by running sudo apt-get install
libc6-dbg:i386
You should use Valgrind in the following manner: valgrind --leak-check=full [your-program] [your-program-options]
<p></p>


<h2>Preparation - Part 0: Memory Leaks, Segmentation Faults, and Printing data from files in hexadecimal format</h2>
<p>
    Programs inevitably contain bugs, at least when they are still being developed. Interactive debugging using
    valgrind(1) helps locate and eliminate bugs. Valgrind assists in discovering illegal memory access even when no
    segmentation fault occurs (e.g., when reading the n+1 place of an array of size n). Valgrind is extremely useful for
    discovering and fixing memory errors (leaks, double free, illegal access, etc.).
</p>
<p>
    To run Valgrind write: valgrind --leak-check=full [program-name] [program parameters].
    Using the command line argument --leak-check=full gives detailed information regarding each leak. Useful for finding
    the source of the leak and fixing it.
</p>
<p>
    You might be able to get more information by running Valgrind in verbose mode like so:<br>
    valgrind -v --leak-check=full [program-name] [program parameters]. You can even increase the level of verbosity by
    multiplying the "v" command line option (in some versions of Valgrind): valgrind -vvv --leak-check=full
    [program-name] [program parameters].
</p>
<p>
    The source code of a buggy program, named <b>Bubblesort</b>, is provided. The program should sort numbers specified in the command line and
    print the sorted numbers, like this:
</p>
<p>
    $ bubblesort 3 4 2 1<br>
    Original array: 3 4 2 1<br>
    Sorted array: 1 2 3 4<br>
</p>
<p>
    However, an illegal memory access causes a segmentation fault (segfault). In addition, the program has a few memory
    leaks. 
</p>
<p>

<b> Part 0 assignments are: </b>
</p>
<p>    
    First, solve the segfault using gdb (or just by reading the code). Then use Valgrind to find the memory leaks and fix
    them.
</p>
<p>
    Then, write a program that receives the name of a binary file as a command-line argument, and prints the hexadecimal value
    of each byte in the file in sequence to the standard output (using printf). Consult the printf(3) man page for
    hexadecimal format printing.
</p>
<p>
    NAME<br>
    &nbsp;&nbsp;&nbsp; hexaPrint - prints the hexdecimal value of the input bytes from a given file<br>
    SYNOPSIS<br>
    &nbsp;&nbsp;&nbsp; hexaPrint FILE<br>
    DESCRIPTION<br>
    &nbsp;&nbsp;&nbsp; hexaPrint receives, as a command-line argument, the name of a "binary" file,
    and prints the hexadecimal value of each byte to the standard output,
    separated by spaces.<br>
</p>
<p>
    For example, your program will print the following output for this <b> exampleFile </b> (download using right click, save
    as):
</p>
<p>
    #&gt;hexaPrint exampleFile<br>
    63 68 65 63 6B AA DD 4D 79 0C 48 65 78
</p>
<p>
    You should implement this program using:<br>
</p><ul>
    <li>fread(3) to read data from the file into memory.</li>
    <li>A helper function, PrintHex(buffer, length), that prints length bytes from memory location buffer, in
        hexadecimal format.
    </li>
</ul>
You will need the helper function during the rest of the assignment, so make sure it is well written and debugged.
<p></p>
<p>
Additionally, make sure your code for the menu at the end of physical presence lab 1 is working and you understand it, as
you will need to implement something similar in this lab.
</p>



<h2>
    The Actual Assignment (Instructions)
</h2>
<p>
    <b>Assignment goals</b> - understanding the following issues: <b> implementing linked lists in C, basic manipulation of
    "binary" files. </b>
    <br>In this lab you will be writing a <b>virusDetector</b> program, to detect computer viruses in a given suspected
    file.
</p>
<p>
    <br>NAME
    <br>&nbsp;&nbsp; virusDetector - detects a virus in a file from a given set of viruses
    <br>SYNOPSIS
    <br>&nbsp;&nbsp; virusDetector FILE
    <br>DESCRIPTION
    <br>&nbsp;&nbsp; virusDetector compares the content of the given FILE byte-by-byte with a pre-&nbsp;&nbsp;defined
    set of viruses described in the file. The comparison is done according to a naive &nbsp;&nbsp;algorithm described in
    task 2.

    <br>&nbsp;&nbsp; FILE - the suspected file
</p>


<h2>
    Part 1: Virus detector using Linked Lists
</h2>
<p>
    In the current part you are required to read the signatures of the viruses from the signatures file and to store
    these signatures in a dedicated linked list data structure. Note, that the command-line argument FILE is not used in
    subparts 1a and 1b below. At a later stage (part 1c) you will compare the virus signatures from the list to byte
    sequences from a suspected file, named in the command-line argument.
</p>

<h3>
    Part 1a - Reading a binary file into memory buffers
</h3>
<p>
    The signatures file begins with a <b>magic number</b> of 4 bytes, that is used to quickly check that this is the right type of file,
	followed immediately by the details of different viruses in a specific format. 
	The magic number of the signature file is the character sequence "VIRL" for little-endian encoding, and "VIRB" for big-endian
	encoding. The rest of the file (after the magic number) consists
	of blocks (&lt; N,name,signature&gt;)
    where each block represents a single virus description.
    <br><br>Notice the format is little endian - the numbers (i.e., the length of the virus) are represented in little
    endian order.
    <br><br>The name of the virus is a null terminated string that is stored in 16 bytes. If the length of the actual
    name is less than 16, then the rest of the bytes are padded with null characters.
</p>
<p>
    The layout of each block is as follows:
</p><table>
    <tbody><tr>
        <th>offset</th>
        <th>size (in bytes)</th>
        <th>description</th>
    </tr>
    <tr>
        <td>0</td>
        <td>2</td>
        <td>The virus's signature length N, up to 2^16 little endian or big endian depending on magic number</td>
    </tr>
    <tr>
        <td>2</td>
        <td>16</td>
        <td>The virus name represented as a null terminated string</td>
    </tr>
    <tr>
        <td>18</td>
        <td>N</td>
        <td>The virus signature</td>
    </tr>
</tbody></table>
<p></p>
<p>
    For example, the following <b>hexadecimal</b> signature (little endian version):
    <br>05 00 56 49 52 55 53 00 00 00 00 00 00 00 00 00 00 00 31 32 33 34 35
    <br>represents a 5-byte length virus, whose signature (viewed as hexadecimal) is:
    <br><br>31 32 33 34 35
    <br>and its name is VIRUS
</p>
<p>
    <br>You are given the following struct that represents a virus description. You are required to use it in your
    implementation of all the tasks.
    <br><br>typedef struct virus {
    <br>unsigned short SigSize;
    <br>char virusName[16];
    <br>unsigned char* sig;
    <br>} virus;
</p>
<p>
    <br>First, you are required to implement the following two auxiliary functions and use them for implementing the
    main parts:
</p><ul>
    <li>void SetSigFileName( ): This function queries the user for a new signature file name, and sets the signature file name accordingly.
	    The default file name (before this function is called) should be "signatures-L" (without the quotes).
    </li><li>virus* readVirus(FILE*): this function receives a file pointer and returns a virus* that represents the next
        virus in the file.
        To read from a file, use fread(). See man fread(3) for assistance.
    </li>
    <li>void printVirus(virus* virus): this function receives a pointer to a virus structure. The
        function prints the virus data to stdout. It prints the virus name (in ASCII), the virus signature length
        (in decimal), and the virus signature (in hexadecimal representation).
    </li>
</ul>
<p></p>
<p>After you implemented the auxiliary functions, implement the following two steps:
</p>
<p>
</p><ul>
    <li>Open the current signatures file, check the magic number, and print an error message and exit if the magic 
	number is incorrect (i.e. different from "VIRL"or "VIRB")
		Then if magic number is OK, use readVirus in order to read the viruses one-by-one, and use printVirus in order to
        print the virus to the standard output.
    </li>
    <li>Test your implementation by comparing your output with the file. Tip for Linux: use diff to compare files line by line. (type man diff for more info)
    </li>
</ul>
<b>Reading into structs</b><br>
The structure of the virus description on file allows reading an entire description into a virus struct in 2 fread
calls. You should read the first 18 bytes directly into the virus struct.
You may need to manipulate the size field.
Then, according to the size, allocate memory
for sig and read the signature directly into it. 

<h3>Part 1b - Linked List Implementation</h3>
Each node in the linked list is represented by the following structure:
<br>typedef struct link link;
<br>
<br><br>struct link {
<br> link *nextVirus;
<br> virus *vir;
<br>};<br>
<br>You are expected to implement the following functions:
<ul>
    <li>void list_print(link *virus_list, FILE*);
        <br>/* Print the data of every link in list to the given stream. Each item followed by a newline character. */
        <br>
    </li>
    <li>link* list_append(link* virus_list, virus* data);
        <br>/* Add a new link with the given data at the beginning of the list
        and return a pointer to the list (i.e., the first link in the list).
        If the list is null - create a new entry and return a pointer to the entry. */
        <br>
    </li>   
    <li>void list_free(link *virus_list);
        <br>/* Free the memory allocated by the list. */
    </li>
</ul>
<br>To test your list implementation you are requested to write a program with the following prompt in an infinite
loop.
You should use the same scheme for printing and selecting menu items as at the end of lab 1 (physical presence lab 1).
<br>0) Set signatures file name
<br>1) Load signatures
<br>2) Print signatures
<br>3) Detect viruses
<br>4) Fix file
<br>5) Quit
<br>
<br> Option 0, Set signatures file name, calls SetSigFileName( ) to change the current signatures file name.
<br>Option 1, Load signatures, uses the currebt signatures file name.
<br><br>After the signatures are loaded, Option 2, Print signatures can be used to print them to the screen. If no file is loaded,
nothing is printed. You should read the user's input using fgets and sscanf. Quit should exit the program.
Detect viruses and Fix file should initially be stub functions that currently just print "Not implemented\n"
(note that these printouts are dropped in the final version of your program).
<br>Test yourself by:
<ul>
    <li>Read the viruse signature structures into buffers in memory.
    </li>
    <li>Creates a linked list that contains all of the viruses where each node represents a single virus.
    </li>
    <li>Prints the content. Here's an example output. File: <b>example output</b>
    </li>
</ul>


<h3>Part 1c - Detecting the virus</h3>
<br>Now, that you have loaded the virus descriptions into memory, extend your virusDetector program as follows:
<ul>
    <li>Implement Detect viruses: operates after the user runs it by entering the appropriate number on the menu,
    </li>
    <li>Open the file indicated by the command-line argument FILE, and fread() the entire contents of the suspected file
        into a buffer of constant size 10K bytes in memory.
    </li>
    <li>Scan the content of the buffer to detect viruses.
    </li>
</ul>
<br>For simplicity, we will assume that the file is smaller than the buffer, or that there are no parts of the virus
that need to be scanned beyond that point, i.e., we will only fill the buffer once. The scan will be done by a function
with the following signature:
<br><br>1. void detect_virus(char *buffer, unsigned int size, link *virus_list)
<br><br>The detect_virus function compares the content of the buffer byte-by-byte with the virus signatures stored in the
virus_list linked list. size should be the minimum between the size of the buffer and the size of the suspected file in
bytes. If a virus is detected, for each detected virus the detect_virus function prints the following details to the
standard output:
<ul>
    <li>The starting byte location in the suspected file
    </li>
    <li>The virus name
    </li>
    <li>The size of the virus signature</li>
</ul>
<br>If no viruses were detected, the function does not print anything.
Use the <b>memcmp(3)</b> function to compare the bytes of the respective virus signature with the bytes of the suspected
file.
<br>You can test your program by applying it to the given file.



<h2>Part 2: Anti-virus Simulation</h2>

<br>In this task you will test your virus detector, and use it to help neutralizing viruses from a file.
The neutralization assumes that the virus is a function that does something and returns.<br>

<h3>Part 2a: Using hexedit</h3>

In this part, you are required to
apply your virus detector to a file, which is infected by a very simple virus that prints the sentence <b>'I am virus1!'</b> to
the standard output. You are expected to cancel the effect of the virus by using the hexedit(1) tool after you find its
location and size using your virus detector.

<br>After making sure that your virus detector program from part 1 can correctly detect the virus information, you are
required to:
<br>1. Download the file (using right click, save as).
<br>2. Set the file permissions (in order to make it executable) using chmod u+x infected, and run it from the terminal
to see what it does.
<br>3. Apply your virusDetector program to the infected file, to find the viruses.
<br>4. Using the hexedit(1) utility and the output of the previous step, find out the viruses location and neutralize them
by replacing the first byte of the virus code by a simple
<a href="https://pdos.csail.mit.edu/6.828/2005/readings/i386/RET.htm">RET</a> (near) instruction. This neutralizes the virus code
by making the virus function return immediately without doing anything else.

<p> Note that part 2a is not submitted, but you will be required to do it during the frontal check of the lab after submmission.
It is also a good idea to do this before implementing part 2b, so you know that the code you write is getting the
correct locations for actually neutralizing the viruses.</p>


<h3>Part 2b: Neutralizing the virus automatically</h3>
<br>Implement the functionality that is described above, do it as follows:
<ul>  
    <li>Implement the "Fix file" option: scan for all viruses in the suspected FILE (the one given
        as the command-line argument), and neutralize them automatically by modifying
	first byte of the virus (equal to the first byte of the signature) to the RET instruction.
	
    </li>
    <li>The fix will be done by the following function:
        <br>void neutralize_virus(char *fileName, int signatureOffset)
    </li>
    <li>Hints: use fseek( ), fwrite( )</li>
</ul>


<h3>Deliverables</h3>
<p> Note, that the assignments in part 0 are not checked and graded. 
<br> For parts 1 and 2, we expect ONE program, containing all subparts solutions and requirements 
(since part 2 builds on part 1), in a single C source-code file, plus an appropriate makefile. 
<br>The deliverables must be submitted before the labs deadline.
<br><br>You must submit a zip file named:{YOUR_ID}.zip, which contains only two files: makefile, and AntiVirus.c


</p><h4>Submission instructions</h4>
<ul>
    <li>Create a zip file with the relevant files (student_id.ZIP).
    </li>
    <li>Upload zip file to the submission system.
    </li>
    <li>Download the zip file from the submission system and extract its content to an empty folder.
    </li>
    <li>Compile and test the code to make sure that it still works.
    </li>
</ul>
<h4> Credit Points per Part </h4>
<table bordera="1" class="content border">
	<tbody><tr><th>Part</th><th>Points</th></tr>
	<tr><td>1</td> <td>60</td></tr>
	<tr><td>2</td> <td>40</td></tr>
</tbody></table>


</body></html>