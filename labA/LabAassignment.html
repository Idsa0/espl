
<!-- saved from url=(0106)https://moodle.bgu.ac.il/moodle/pluginfile.php/4400651/mod_resource/content/17/LabAassignment.html?embed=1 -->
<html data-darkreader-mode="dynamic" data-darkreader-scheme="dark"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><style class="darkreader darkreader--fallback" media="screen"></style><style class="darkreader darkreader--text" media="screen"></style><style class="darkreader darkreader--invert" media="screen">.jfk-bubble.gtx-bubble, .captcheck_answer_label > input + img, span#closed_text > img[src^="https://www.gstatic.com/images/branding/googlelogo"], span[data-href^="https://www.hcaptcha.com/"] > #icon, ::-webkit-calendar-picker-indicator, img.Wirisformula {
    filter: invert(100%) hue-rotate(180deg) contrast(90%) !important;
}</style><style class="darkreader darkreader--inline" media="screen">[data-darkreader-inline-bgcolor] {
  background-color: var(--darkreader-inline-bgcolor) !important;
}
[data-darkreader-inline-bgimage] {
  background-image: var(--darkreader-inline-bgimage) !important;
}
[data-darkreader-inline-border] {
  border-color: var(--darkreader-inline-border) !important;
}
[data-darkreader-inline-border-bottom] {
  border-bottom-color: var(--darkreader-inline-border-bottom) !important;
}
[data-darkreader-inline-border-left] {
  border-left-color: var(--darkreader-inline-border-left) !important;
}
[data-darkreader-inline-border-right] {
  border-right-color: var(--darkreader-inline-border-right) !important;
}
[data-darkreader-inline-border-top] {
  border-top-color: var(--darkreader-inline-border-top) !important;
}
[data-darkreader-inline-boxshadow] {
  box-shadow: var(--darkreader-inline-boxshadow) !important;
}
[data-darkreader-inline-color] {
  color: var(--darkreader-inline-color) !important;
}
[data-darkreader-inline-fill] {
  fill: var(--darkreader-inline-fill) !important;
}
[data-darkreader-inline-stroke] {
  stroke: var(--darkreader-inline-stroke) !important;
}
[data-darkreader-inline-outline] {
  outline-color: var(--darkreader-inline-outline) !important;
}
[data-darkreader-inline-stopcolor] {
  stop-color: var(--darkreader-inline-stopcolor) !important;
}
[data-darkreader-inline-bg] {
  background: var(--darkreader-inline-bg) !important;
}
[data-darkreader-inline-invert] {
    filter: invert(100%) hue-rotate(180deg);
}</style><style class="darkreader darkreader--variables" media="screen">:root {
   --darkreader-neutral-background: #131516;
   --darkreader-neutral-text: #d8d4cf;
   --darkreader-selection-background: #004daa;
   --darkreader-selection-text: #e8e6e3;
}</style><style class="darkreader darkreader--root-vars" media="screen"></style><style class="darkreader darkreader--user-agent" media="screen">@layer {
html {
    background-color: #181a1b !important;
}
html {
    color-scheme: dark !important;
}
iframe {
    color-scheme: initial;
}
html, body {
    background-color: #181a1b;
}
html, body {
    border-color: #736b5e;
    color: #e8e6e3;
}
a {
    color: #3391ff;
}
table {
    border-color: #545b5e;
}
mark {
    color: #e8e6e3;
}
::placeholder {
    color: #b2aba1;
}
input:-webkit-autofill,
textarea:-webkit-autofill,
select:-webkit-autofill {
    background-color: #404400 !important;
    color: #e8e6e3 !important;
}
::-webkit-scrollbar {
    background-color: #202324;
    color: #aba499;
}
::-webkit-scrollbar-thumb {
    background-color: #454a4d;
}
::-webkit-scrollbar-thumb:hover {
    background-color: #575e62;
}
::-webkit-scrollbar-thumb:active {
    background-color: #484e51;
}
::-webkit-scrollbar-corner {
    background-color: #181a1b;
}
::selection {
    background-color: #004daa !important;
    color: #e8e6e3 !important;
}
::-moz-selection {
    background-color: #004daa !important;
    color: #e8e6e3 !important;
}
}</style><meta name="darkreader" content="bf44469878d947cdb8789b4d58571a6d"><style class="darkreader darkreader--override" media="screen">.vimvixen-hint {
    background-color: #7b5300 !important;
    border-color: #d8b013 !important;
    color: #f3e8c8 !important;
}
#vimvixen-console-frame {
    color-scheme: light !important;
}
::placeholder {
    opacity: 0.5 !important;
}
#edge-translate-panel-body,
.MuiTypography-body1,
.nfe-quote-text {
    color: var(--darkreader-neutral-text) !important;
}
gr-main-header {
    background-color: #0f3a48 !important;
}
.tou-z65h9k,
.tou-mignzq,
.tou-1b6i2ox,
.tou-lnqlqk {
    background-color: var(--darkreader-neutral-background) !important;
}
.tou-75mvi {
    background-color: #032029 !important;
}
.tou-ta9e87,
.tou-1w3fhi0,
.tou-1b8t2us,
.tou-py7lfi,
.tou-1lpmd9d,
.tou-1frrtv8,
.tou-17ezmgn {
    background-color: #0a0a0a !important;
}
.tou-uknfeu {
    background-color: #231603 !important;
}
.tou-6i3zyv {
    background-color: #19576c !important;
}
div.mermaid-viewer-control-panel .btn {
    background-color: var(--darkreader-neutral-background);
    fill: var(--darkreader-neutral-text);
}
svg g rect.er {
    fill: var(--darkreader-neutral-background) !important;
}
svg g rect.er.entityBox {
    fill: var(--darkreader-neutral-background) !important;
}
svg g rect.er.attributeBoxOdd {
    fill: var(--darkreader-neutral-background) !important;
}
svg g rect.er.attributeBoxEven {
    fill: var(--darkreader-selection-background);
    fill-opacity: 0.8 !important;
}
svg rect.er.relationshipLabelBox {
    fill: var(--darkreader-neutral-background) !important;
}
svg g g.nodes rect,
svg g g.nodes polygon {
    fill: var(--darkreader-neutral-background) !important;
}
svg g rect.task {
    fill: var(--darkreader-selection-background) !important;
}
svg line.messageLine0,
svg line.messageLine1 {
    stroke: var(--darkreader-neutral-text) !important;
}
div.mermaid .actor {
    fill: var(--darkreader-neutral-background) !important;
}
.google-material-icons {
    font-family: 'Google Material Icons' !important;
}
.google-symbols {
    font-family: 'Google Symbols Subset', 'Google Symbols' !important;
}
.material-icons-extended {
    font-family: 'Material Icons Extended' !important;
}
mitid-authenticators-code-app > .code-app-container {
    background-color: white !important;
    padding-top: 1rem;
}
iframe#unpaywall[src$="unpaywall.html"] {
    color-scheme: light !important;
}
.oui-icon {
    font-family: 'Oui Icons' !important;
}</style></head><body><h1>Introduction to C Programming in a Unix (Linux 32 bits) Environment</h1>
<h1>This lab assignment is to be done SOLO!</h1>

<h2>Home-Lab A -- Assignment goals: </h2> 
<ul>
<li> C primer
</li><li> Parsing command-line arguments
</li><li> Undestanding character encoding (ASCII)
</li><li> Implementing a debug mode for your program
</li><li> Introduction to standard streams (stdin, stdout, stderr)
</li><li> Simple stream IO library functions
</li></ul>


<h2>Preparation - Part 0: Maintaining a project using <tt>make</tt></h2>
<p>You should perform this part <b>before</b> starting to implement the
hand-in assignment. It is basic knowledge that is not checked, but needed to complete the assignment.
</p><p>For this part, 3 files are provided: <b>add.s</b>, <b>main.c</b>, <b>numbers.c</b>. The first file is assembly language code, and the other 2 are C source code.

</p><ol> 
  <li> Log in to Linux.
  </li><li> Decide on an ASCII text editor of your choice (vi, emacs, kate, pico, nano, femto, or whatever). It is <b>your responsibility</b> to know how to operate the text editor well enough for all tasks in all labs.
  </li><li> Using the text editor that you decided to use, write a makefile for the given files (as explained in the introduction to GNU Make Manual, see the <b> Reading Material for Lab A </b>. The Makefile should provide targets for compiling the program and cleaning up the working directory. 
  </li><li> Compile the project by executing make in the console.
  </li><li> Read all of lab A reading material, and make sure you <b>understand</b> it. 
  </li><li> Read the puts(3) and printf(3) manuals. What is the difference between the functions? To read the manuals type man followed by the function name (e.g. <code>man puts</code>) in a "console".
</li></ol>


<h3> Important </h3>
To protect your files from being viewed or copied by other people, thereby possibly earning you a disciplinary hearing, employ the Linux permission system by running:
<code> chmod 700 -R ~</code>
In order to make sure you have sufficient space in your workspace,
run the following command once you're logged in
<code> du -a | sort -n </code>
Then you can see a list of your files/directories
and the amount of space each file/directory takes.
If you need space and KNOW which files to remove, you can do that by:
<code> rm -f [filename] </code>


<h3>Unix: Control+D, Control+C and Control+Z</h3>
<ul>
<li> What does Control+D (^D) do?
Control+D causes the Unix terminal driver to signal the EOF condition to the process running in this terminal foreground. You can read more about it <a href="http://en.wikipedia.org/wiki/End-of-transmission_character">here</a>.
</li><li> What does Control+C (^C) do?
Pressing Control+C in the terminal, causes the Unix terminal to send the SIGINT signal to the process running in the terminal foreground. This will usually terminate the process.
</li><li> What does Control+Z (^Z) do?
Pressing Control+Z in the terminal, causes the Unix terminal to send the SIGTSTP signal to the process running in the terminal foreground. This will suspend the process (meaning the process will still live in background).
</li><li> Do not use Control+Z for terminating processes!!!
</li></ul>


<h3>Writing a simple program</h3>
First, re-read and understand the arguments of main(argc, argv), which represent the command-line arguments in the line used to run any program using a "console". 
Recall that argc is the number of arguments, and that argv is an array of pointers to locations containing "null terminated strings" - 
the command line arguments, with argv[0] pointing to the program file name used in the command line to run the program.
Then, write a simple echo program named my_echo:
<dl>
  <dt> NAME </dt>
  <dd> my_echo - echoes text.</dd>
  <dt> SYNOPSIS </dt>
  <dd> my_echo </dd>
  <dt> DESCRIPTION </dt>
  <dd> my_echo prints out the text given in the command line by the user.
  </dd>  
  <dt> EXAMPLES </dt>
  <dd>
    <code>
#&gt; my_echo aa b c
aa b c
    </code>
  </dd><dd>
</dd></dl>

<h4> Mandatory requirements</h4>
<ul>
  <li> Create a proper makefile as described in the reading material.
  </li><li> Test your program to see that it actually works.
</li></ul>



<h1> The actual assignment</h1>

<p>
Make sure you have done part 0 before you start implementing this assignment, especially the semantics of arguments of main( ).
In this simple assignment you will be writing a simple <b>encoder program</b>.
The program has three functionalities:
</p><ol>
<li> Parsing the command-line arguments and printing debug messages.
</li><li> The actual encoder.
</li><li> Redirecting the input and output according to the command-line arguments.
</li></ol>

Although you will be submitting a single program containing all the above, it is highly recommended that you implement 
each step in the above order and test it thoroughly before proceeding to the next one. 
There are several reasons for this. First, the step-by-step scheme is how physical labs will be run. 
But more in general, it is important to be able to partition the work and test functionalities separately, 
this leads to much more efficient and correct code developement.


<h2>Part 1: Command-Line Arguments and Debugging</h2>

First, make sure you have done part 0 before you start implementing this assignment, especially the semantics of arguments of main( ).

<p>
Second, introduce a debug mode into your program. 
For this we will develop an easy debugging scheme which can be used with any program
and allows for special debugging features for testing. 
The minium implementation prints out important information to stderr when in debug mode.
Printing out the command-line arguments allows for easy detection of errors in retrieving them.
Henceforth, code you write in most labs and assignments will also require adding a debug mode, and it is a good idea to
have this option in <b>all</b> programs you write, even if <b>not required</b> to do so!

</p><p>
For this scheme, you must simply loop over the command-line arguments, and if in debug mode, print each argument on 
a separate "line" to stderr. 
Debug mode is a variable that you can choose to initialize to "on" or "off" (default: <b>on</b>), but if there is a command line
argument "-D" it turns debug mode off, and if there is a command-line argument "+D" it turns the debug mode on.
For simplicity, we require the effect of a debug flag change to occur <b>immediately after</b> the current command line
argument is handled, that is, starting with the <b>next</b> command line argument.

Use fprintf( ) -- see manual -- for simple printing of "strings" on separate lines.
Note, that the output should be to stderr, rather than stdout, to differentiate between 
regular program output (currently null) and debug/error messages from the program.



</p><h2>Part 2: The Encoder</h2>

In this part you will first use the command-line parsing to detect a possible
encoding string, and use that to modify the output behaviour. With no encoding string (default),
every input character (from stdin) is simply sent to the output (stdout). 
That is, you read a character using fgetc( ), possibly encode it, and then
print it after modification using fputc( ), until detecting an EOF condition in the input (preferably using feof( )),
at which point you should close the output stream and exit "normally".
We recommend here that you use varibles such as infile and outfile as arguments to
fgetc() and fputc() respectively, initilized by default to stdin and stdout, respectively.
This will allow you to do the last part with very little effort.

<p>
The encding works as follows. The encryption key is of the following structure: +e{key}. 
The argument {key} stands for a sequence of digits whose value will be <b>added</b> to each input characters in sequence,
in a <b>cyclic</b> manner.<br> This means that each digit in sequence recieved by the encoder is added to the coresponding
character in sequence in the key. When and if the end of the key is reached, 
re-start reading encoding digits from the begining of the key.
You should support both addition and subtraction, +e{key} is for addition and -e{key} is for subtraction.

</p><p>
Implementation is as follows. The key value, if any, is provided as a command-line argument.
As stated above, this is indicated by a command line argument such as "+e1234" or
"-e13061". The first is a sequence of numbers to be <b>added</b> to the input characters
before they are emitted, while the second is a sequence of numbers to be <b>subtracted</b>
from the input characters. Assumptions are: only at most one of "+e" or "-e" are present,
and the rest of the commend line argument is always (only) a non-empty sequence of decimal digits,
terminated as usual by a null character. 

</p><p>
Encoding is as follows: to the first character of the
input, add the numerical value of the first encoding digit, to the second input character
add the (numerical value of the) second digit, etc. If you reach the end of the encoding string
(null character!) before you reach EOF in the input, reset to the beginning of the encoding string. 
Observe that this is ASCII encoding, so it should be <b>very simple</b> to compute the numeric value of each digit, 
which you should do directly using no special functions.

Note that we advance in the encoding key once for each input character, but encoding, if indicated, 
should only be applied to lower case and digit characters,
that is 0-9, and a-z, and should use "wrap around", that is assume z+1 is a, and a-1 is z. etc.
Examples are provided below to fully clarify this.

</p><h4>Examples</h4>
In the first example below see how the a,b,b,d,e are encoded adding 1,2,3,4,5
respectively and then for the next character the encoding key is reset to 1 for the next character, z.
But z+1 is wrapped around and becomes a. Then there is a newline character, which is output
with no change (still advancing the encoding key) so to the next characeter 3 is added,
and to the one after that 4 is added. The last 2 characters again are output with no change.
The 2nd example below is similar but now with a key to subtract, rather than add.

<pre>#&gt; encoder +e12345
abcdez
bdfhja
12#&lt;
46#&lt;
^D
#&gt; encoder -e4321
gduqp523
caspl202
^D
</pre> 


<h2>Part 3: Input and/or Output to Specific Files</h2>

<p>
The default operation of your program is to read characters from stdin (the "console" keyboard),
encode them as needed, and output the results to stdout (the "console" display).
After checking correctness of all the previous parts, now add the option for reading
the input from a specified input file: if command-line argument "-Ifname" is present,
the input should be read from a file called "fname"  instead of stdin (or in general the file name starts immediately
after the "-I" and ends at the null character). Likewise, if command-line argument
"-Ofname" is present, the output should go to a file name "fname" (or in general, file name immediately after
the "O").
</p><p>
Observe that if you did things right and heeded our advice above, this part is only a few lines of
code: while scanning the command-line arguments simply check for "-I" and "-O" and open
input and/or output files as needed using fopen( ), and use the file descriptor it returns
for the value of "infile" and/or "outfile". The rest of the program does not need to change
at all. Just make sure that if fopen( ) fails, print an error message to stderr and exit.
Note that your program should support encoding keys, input file setting, output file setting, and
debug flag setting, in any combination or order. You may assume that at most one
of each will be given (e.g. no more than one encoding key, and no more than one output file
setting).

</p><p><b>Optionally</b>, when debug mode is on, your encoder may print to stderr any information you wish, such as
the input character and the encoding value, to help you in debugging your code. It is OK to leave this in the submitted version,
as we are not requiring a specific result in stderr.
</p>

<p>

</p><h4> Helpful Information  and Hints</h4>
<ul>
<li> stdin and stdout are FILE* constants than can be used with fgetc and fputc.
</li><li> Make sure you know how to recognize end of file (<i> EOF </i>).
</li><li> Control-D causes the Unix terminal driver to signal the EOF condition to the process running in this terminal foreground, using this key combination (shown in the above example as ^D) will cause <i>fgetc()</i> to return an <i>EOF</i> constant and in response your program should terminate itself "normally".
</li><li> Refer to <a href="http://www.asciitable.com/">ASCII</a> table for more information on  
characters encoding.
</li><li> Remember that "character strings" in C are simply null terminated arrays of "unsigned char",
to which, obviously, a pointer can point. Thus, when accessing parts of such it is better and simpler <b>not</b>
to use library string functions such as strcpy, strlen, and the like. In fact, even though we allow you to use "strncmp" or "strcmp" to
detect things like "+e" in the command line, a more concise and preferred implementation actually does <b>not</b> use them, instead comparing individual characters!
</li><li> In every do-at-home lab, we designate some issues as "may obtain help". By this we mean there will be an <b>optional</b>
task in a concurrent physical-attendance lab (in this case lab 1), where you may obtain help from a TA and
make sure you are doing things correctly. This does <b>not</b> mean that you can expect the lab TA to do your work for you,
only help to clarify mesconceptions and difficulties.
In this assignment the following issues are so designated:
<ol>
<li> Corrently detecting the end-of-file condition in the input file.
</li><li> Correct use of makefiles.
</li></ol>
</li></ul>

<h4> Mandatory requirements</h4>
<ul>
<li> You must read and process the input <b>character by character</b>, there is no need to store the characters you read at all,
except for the character currently being processed.
</li><li> Important - you cannot make any assumption about the line lengths.
</li><li> Check whether a character is an lowercase (letter resp. uppercase, or number) by using a single "if" statement with two conditions. How?
</li><li> You are <b>not</b> allowed to use any library function for the purpose of recognizing whether a character is a letter, and its case.
</li><li> Points will be deducted for using string library functions "strlen", "strcpy", and all others except for "strncmp" and "strcmp".
The latter (strncmp, strcmp) are allowed with no penalty, but not recommended.
</li><li> Read your program parameters in the same way as in Part 0's: main.c. 
First, set default values to the variables holding the program configuration and then scan 
through <i>argv</i> to update those values. 
Points will be reduced for failing to do so.
</li><li>Program arguments may arrive in an <b>arbitrary</b> order. Your program must support this feature. 
</li><li> Output to stdout (or ofname) must contain <b>only</b> the (possibly encoded) characters from the input,
this will undergo automated checking so any deviation will cause faling automated tests and a grade reduction.
For the debug printouts (in stderr) we will not enforce a specific format.
</li></ul>

<h1> Submission </h1>  
In the following submission instructions and deliverables as well as point distribution.

<h4> Submission instructions</h4>
<ul>
<li> Create a zip file with the relevant files (only).
</li><li> Upload zip file to the submission system.
</li><li> Download the zip file from the submission system and extract its content to an empty folder.
</li><li> Compile and test the code to make sure that it still works.
</li><li> In this case the makefile should be set so that "make encoder" generates an executable
file of your program with the name "encoder" in its current directory, and with no additional directory structure.
</li></ul>  

<h4> Deliverables</h4>

<p>A zip file containing exactly the following files:</p>

<ol>
<li>makefile
</li><li>encoder.c
</li></ol>



<h4>Credit Points per Part</h4>
<table bordera="1" class="content border">
	<tbody><tr><th>Part</th><th>Points</th></tr>
	<tr><td>1</td> <td>20</td></tr>
	<tr><td>2</td> <td>50</td></tr>
	<tr><td>3</td> <td>30</td></tr>

</tbody></table>



</body></html>