
<!-- saved from url=(0108)https://moodle.bgu.ac.il/moodle/pluginfile.php/4400693/mod_resource/content/7/NewLab3Tasks2024B.html?embed=1 -->
<html data-darkreader-mode="dynamic" data-darkreader-scheme="dark"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><style class="darkreader darkreader--fallback" media="screen"></style><style class="darkreader darkreader--text" media="screen"></style><style class="darkreader darkreader--invert" media="screen">.jfk-bubble.gtx-bubble, .captcheck_answer_label > input + img, span#closed_text > img[src^="https://www.gstatic.com/images/branding/googlelogo"], span[data-href^="https://www.hcaptcha.com/"] > #icon, ::-webkit-calendar-picker-indicator, img.Wirisformula {
    filter: invert(100%) hue-rotate(180deg) contrast(90%) !important;
}</style><style class="darkreader darkreader--inline" media="screen">[data-darkreader-inline-bgcolor] {
  background-color: var(--darkreader-inline-bgcolor) !important;
}
[data-darkreader-inline-bgimage] {
  background-image: var(--darkreader-inline-bgimage) !important;
}
[data-darkreader-inline-border] {
  border-color: var(--darkreader-inline-border) !important;
}
[data-darkreader-inline-border-bottom] {
  border-bottom-color: var(--darkreader-inline-border-bottom) !important;
}
[data-darkreader-inline-border-left] {
  border-left-color: var(--darkreader-inline-border-left) !important;
}
[data-darkreader-inline-border-right] {
  border-right-color: var(--darkreader-inline-border-right) !important;
}
[data-darkreader-inline-border-top] {
  border-top-color: var(--darkreader-inline-border-top) !important;
}
[data-darkreader-inline-boxshadow] {
  box-shadow: var(--darkreader-inline-boxshadow) !important;
}
[data-darkreader-inline-color] {
  color: var(--darkreader-inline-color) !important;
}
[data-darkreader-inline-fill] {
  fill: var(--darkreader-inline-fill) !important;
}
[data-darkreader-inline-stroke] {
  stroke: var(--darkreader-inline-stroke) !important;
}
[data-darkreader-inline-outline] {
  outline-color: var(--darkreader-inline-outline) !important;
}
[data-darkreader-inline-stopcolor] {
  stop-color: var(--darkreader-inline-stopcolor) !important;
}
[data-darkreader-inline-bg] {
  background: var(--darkreader-inline-bg) !important;
}
[data-darkreader-inline-invert] {
    filter: invert(100%) hue-rotate(180deg);
}</style><style class="darkreader darkreader--variables" media="screen">:root {
   --darkreader-neutral-background: #131516;
   --darkreader-neutral-text: #d8d4cf;
   --darkreader-selection-background: #004daa;
   --darkreader-selection-text: #e8e6e3;
}</style><style class="darkreader darkreader--root-vars" media="screen"></style><style class="darkreader darkreader--user-agent" media="screen">@layer {
html {
    background-color: #181a1b !important;
}
html {
    color-scheme: dark !important;
}
iframe {
    color-scheme: initial;
}
html, body {
    background-color: #181a1b;
}
html, body {
    border-color: #736b5e;
    color: #e8e6e3;
}
a {
    color: #3391ff;
}
table {
    border-color: #545b5e;
}
mark {
    color: #e8e6e3;
}
::placeholder {
    color: #b2aba1;
}
input:-webkit-autofill,
textarea:-webkit-autofill,
select:-webkit-autofill {
    background-color: #404400 !important;
    color: #e8e6e3 !important;
}
::-webkit-scrollbar {
    background-color: #202324;
    color: #aba499;
}
::-webkit-scrollbar-thumb {
    background-color: #454a4d;
}
::-webkit-scrollbar-thumb:hover {
    background-color: #575e62;
}
::-webkit-scrollbar-thumb:active {
    background-color: #484e51;
}
::-webkit-scrollbar-corner {
    background-color: #181a1b;
}
::selection {
    background-color: #004daa !important;
    color: #e8e6e3 !important;
}
::-moz-selection {
    background-color: #004daa !important;
    color: #e8e6e3 !important;
}
}</style><meta name="darkreader" content="0e1e85b5c8924cbd8684daa0ff79900f"><style class="darkreader darkreader--override" media="screen">.vimvixen-hint {
    background-color: #7b5300 !important;
    border-color: #d8b013 !important;
    color: #f3e8c8 !important;
}
#vimvixen-console-frame {
    color-scheme: light !important;
}
::placeholder {
    opacity: 0.5 !important;
}
#edge-translate-panel-body,
.MuiTypography-body1,
.nfe-quote-text {
    color: var(--darkreader-neutral-text) !important;
}
gr-main-header {
    background-color: #0f3a48 !important;
}
.tou-z65h9k,
.tou-mignzq,
.tou-1b6i2ox,
.tou-lnqlqk {
    background-color: var(--darkreader-neutral-background) !important;
}
.tou-75mvi {
    background-color: #032029 !important;
}
.tou-ta9e87,
.tou-1w3fhi0,
.tou-1b8t2us,
.tou-py7lfi,
.tou-1lpmd9d,
.tou-1frrtv8,
.tou-17ezmgn {
    background-color: #0a0a0a !important;
}
.tou-uknfeu {
    background-color: #231603 !important;
}
.tou-6i3zyv {
    background-color: #19576c !important;
}
div.mermaid-viewer-control-panel .btn {
    background-color: var(--darkreader-neutral-background);
    fill: var(--darkreader-neutral-text);
}
svg g rect.er {
    fill: var(--darkreader-neutral-background) !important;
}
svg g rect.er.entityBox {
    fill: var(--darkreader-neutral-background) !important;
}
svg g rect.er.attributeBoxOdd {
    fill: var(--darkreader-neutral-background) !important;
}
svg g rect.er.attributeBoxEven {
    fill: var(--darkreader-selection-background);
    fill-opacity: 0.8 !important;
}
svg rect.er.relationshipLabelBox {
    fill: var(--darkreader-neutral-background) !important;
}
svg g g.nodes rect,
svg g g.nodes polygon {
    fill: var(--darkreader-neutral-background) !important;
}
svg g rect.task {
    fill: var(--darkreader-selection-background) !important;
}
svg line.messageLine0,
svg line.messageLine1 {
    stroke: var(--darkreader-neutral-text) !important;
}
div.mermaid .actor {
    fill: var(--darkreader-neutral-background) !important;
}
.google-material-icons {
    font-family: 'Google Material Icons' !important;
}
.google-symbols {
    font-family: 'Google Symbols Subset', 'Google Symbols' !important;
}
.material-icons-extended {
    font-family: 'Material Icons Extended' !important;
}
mitid-authenticators-code-app > .code-app-container {
    background-color: white !important;
    padding-top: 1rem;
}
iframe#unpaywall[src$="unpaywall.html"] {
    color-scheme: light !important;
}
.oui-icon {
    font-family: 'Oui Icons' !important;
}</style></head><body><h1>Lab 3: Assembly Language and System Calls Primer</h1>

<h3>Lab Goals</h3>
<ul>
    <li>Initial introduction to writing simple programs in assembly language.</li>
    <li>To get acquainted with the low-level interface to system calls.</li>
    <li>Calling assmebly code from C and vice-versa.</li>
    <li>Basics of directory listings.</li>
 </ul>

<h1>This lab may be done in pairs!</h1>

<tip title="">
As usual, you should read and understand the reading material and complete task 0 before attending the lab. <br>
<b>For the entire lab, do not use the standard library!
This means you shouldn't include stdio.h, stdlib.h, and do not link to any other file from the C standard library. You can, 
however, include your own files or any files we provide you.
This also means that you cannot use any library functions like printf, fopen, fgetc, strcmp, etc.</b>

</tip>

<h1>Task 0: Using nasm, ld and the Arguments Printing Program</h1>
In this task we will build a program which prints its arguments to standard output without using the standard C library.


<h3>Task 0.A: C Implementation</h3>
<ol>
  <li>Download the files main.c, start.s, util.c and util.h.</li>
  <li>Compile and link them without using the C standard library as follows:
    <ul>
      <li>
          Assemble the glue code:<br>
          nasm -f elf32 start.s -o start.o
      </li>
        <li>
            Compile the main.c and util.c files into object code files:<br>
            gcc -m32 -Wall -ansi -c -nostdlib -fno-stack-protector util.c -o util.o<br>
            gcc -m32 -Wall -ansi -c -nostdlib -fno-stack-protector main.c -o main.o
        </li>
        <li>
            Link everything together:<br>
            ld -m elf_i386 start.o main.o util.o -o task0
        </li>
    </ul>
  </li>
    <li>Write a makefile to perform the compilation steps automatically.</li>
    <li>Write a new main.c that prints the elements of argv to the standard output, without using stdlib. This part is important, as
	here is where you make sure that you have the compiler set up correctly to work 
	using the CDECL C calling convention, as described in class.</li>
</ol>

<b>Explanation</b>
<br>
The file "start.s" has two purposes:
<br>
<ol>
    <li>
        Each executable must have an entry point - the position in the code where execution starts.
        By default, the linker sets this entry point to be a library supplied code or function that begins at _start.
        This code is responsible for initializing the program: it prepares the stack so as to have argc and argv in the
		format expected by main().
		After initialization, this code passes control to the main() function.
        Since we are not using any standard libraries,  we must supply the linker with _start of our own - which is defined in start.s.
    </li>
    <li>
        The assembly-language source code in start.s also contains the system_call function,
        which can be used to get a direct system call without requiring you to write in assembly language.
		That is, it receives arguments on the stack in CDECL format, places them in the appropriate registers and performs the system call.
		You can either use it if you wish, but it is better to look at this as an example how
		"arguments" to system calls are placed in registers before the INT 0x80 instruction actually executing the system call.
        Note that you can link files written in different languages: an object file is an object file, no matter where it came from.
        All is machine code at some point!
    </li>
</ol>

<h3>Task 0.B: Assembly Language Primer</h3>

Implement a stand-alone program in assembly language that prints a constant string, such as "hello world" and a linefeed to stdout.
For this sub-task you need to read about argument passing to a system call in assembly, and look at start.s as
an example. Your program should not use anything other than Linux system services.

<h3>Task 0.C: Recalling encoder from lab A</h3>

<p>Make sure you have a <b>good</b> implementation in C of the encoder from lab A, in the sense that it has handled the tasks
with a good understanding of low-level features. 
That is because later on in the lab you will need to implement a simplified form in assembly language with direct system calls.
A good low-level C implementation will make the task immediate, whereas an implementation without a care for details and
understanding of low-level features (e.g. what is the end of a "string"?) will be extremely unhelpful. Consider that any place 
you have used
"strlen", "strcpy", strcmp", and especially if you did something like "strlen{encoding)%i" you are <b>not</b> well prepared.</p>

<p>If you <b>do not</b> have a good implementation of the encoder from lab A, consider the following advice. You may also
borrow lab A solutions in C from other people (<b>only</b>) as preparation for lab 3, but of course you should say 
your implementation is based on
(appropriate citation) C code from another source. In this instance only this is permitted and will cause no grade reduction!
If, on the other hand, you <b>do</b> have a good low level implementation of the encoder from lab A, this task 0.C can be 
considered a "nop",
and ignore the rest of task 0.C.
That is, you are ready in this aspect due to a previously well done job! (As the saying goes <b>"Mi She Tarakh Be Erev Shabat, Yokhal Be Shabat"</b>).</p>


<h4>Low-level encoder tips</h4>

A good low-level implementation of the encode is easy to transfer to assembly language. Good is according to the tips below:
<ol>
<li> Note that you never need to "copy" a "string" in this task. Rather you can always maintain a pointer to its start,
as do not need to modify such "strings". Therefore, you should not be copying any such, and certainly not use "strcpy".
See next tip.</li>
<li>Recall that a "string" is simply an array of bytes, and that a pointer can be seen as a reference to the array,
or any part thereof if it is advanced. So no need to use "strcmp" to detect command-line flags. For example, to do the output file case,
can simply do in the loop on arguments:
<pre>   char * OutFileName;
   FILE * OutFile;
   if(av[i][0] == '-' &amp;&amp; av[i][1] == 'O') {  /* Can actually be done in 1 instruction, e.g.:  CMP word [eax], '-'+(256*'O')  ; equivalently "-O" */
       OutFileName = (av[i])+2;
	   OutFile = fopen(OutFileName, "w");
	   if(Outfile == NULL) { /* error, print "cannot open file" and exit */}
   }
</pre>
</li>
<li> To find the start of the encoding string, same (av[i])+2 as above works:
<pre>   unsigned char * EncoderString, * CurrentEncodeP, EncodeByte;
    if(av[i][0] == '+' &amp;&amp; av[i][1] == 'e') {
       CurrentEncodeP = EncoderString = (av[i])+2;
	   if(*EncoderString == 0) /* Error, null encoder string, exit */
   }
   /* And then, later on, after getting each character c: */
   EncodeByte = (*CurrentEncodeP)-'0';
   c += EncodeByte;
   CurrentEncodeP++;
   /* And then below wrap around to start at null termination */
   if(*CurrentEncodeP == 0) { CurrentEncodeP = EncoderString; }  
</pre>
</li>
</ol>




<h1>Task 1: Simplified Encoder In Assembly Language</h1>

Recall the encoder program from lab A (a long time ago!). We want to implement a simplified version  
of the encoder program in <b>assembly using system calls</b>. Please note again that your code
(including the function main) should be exclusively in assembly language, and use no library functions.
You may still call functions from "util.c" which we provide.

<br>
Overall, the encryption program should support the following command-line arguments:
<ul>
    <li>-i{file} - get input from the given file.</li>
    <li>-o{file} - direct output to the given file.</li>
</ul>
The encoder will be a simplified version that reads a character (from stdin by default),
encodes it by adding 1 to the character value
if it is in the range 'A' to 'z' (no encoding otherwise), and outputs it (to stdout by default).
We do this in the 3 subtasks below.

<h3>Task 1.A: Debug printout in assembly language</h3>

This part achieves access to arguments in cdecl C calling convention, and acts like the debug printout
of lab A. Except now debug is always on, so all command line arguments are printed to stderr.

Write a function called main in assembly language that prints all the command line arguments to stdout,
each on a separate line, using only direct system calls (that is, use "write" system call, number 4).
You are supposed to use no library functions, but may use our "strlen" provided in util.c.
The program should then exit "normally" using
the exit system call (system call number 1).

<h3>Task 1.B: Basic Encoder Version</h3>

In this section you are required to implement the encoder program from stdin to stdout
(use the appropriate system calls for reading or writing). Extend the code from Task 1.A
to do this. We suggest using another function called encode to do this. For simplicity we also
suggest using global variables "Infile" and "Outfile" (appropriately initialized) rather than constants in the system calls,
in order to speed up the next subtask.

<h3>Task 1.C: Encoder Version With Input and Output Support</h3>

Add to your program the option of the following command line arguments:
<ul>
    <li>-i{file} - get input from the given file.</li>
    <li>-o{file} - direct output to the given file.</li>
</ul>

Recall from Task 0.C how to access the file name, to be used in the system call.
Also, note that the system call is equivalent to "open", except for the return value (file descriptor or error), which is in the EAX register, rather than "fopen".

<h1>Task 2: Attach Virus Program</h1>

Many computer viruses attach themselves to executable files that may be part of legitimate programs.
If a user attempts to launch an infected program, the virus code is executed before the infected program code.
The goal is to write a program that attaches its own code at the end of a given file.
Note that here you will be writing partly in C and partly in assembly language, so your program code will
consist of 2 files: main.c, and (an extended version) of start.s, beginning with the start.s we provide.

<br>
<p>
<b>DESCRIPTION</b>
<br>
Your program receives a command line argument, which includes the name of a file:

</p>
<p>
<b>COMMAND-LINE ARGUMENT</b>
<br>
-a{file} - attach the executable code to the given file.
<br>
Attach the executable code (be discussed more below) at the end of given file name.
After attaching the code, the program should print the message
<b>"VIRUS ATTACHED"</b> after the file name.
</p>


<h4>Some guidelines</h4>
<ol>
    <li>In case of an error, the program should terminate with exit code 0x55.</li>
     <li>Do not forget not to use any standard library functions!.
        Instead, in "util.h" and "util.c", you can find few implementation
        for some helpful functions. You may use them.</li>
</ol>

<h3>Task 2.A: Parse and print the file name</h3>
Write the function main( ) in C: retrieve and print the file name given in the command line to the screen,
and then call the functions "infection( )" and "infector(filename)", with filename as given in the command-line argument.
Both these functions are to be written in assembly language, at this point make them "stubs": both just consist of the "ret" instruction.

Now, compile, link, and test your code.


<h3>Task 2.B: attaching the virus</h3>

Now implement the "-a" option to attach the virus.

<b>Warning:</b> You probably want to be very sure that the mechanism for determining the file name works correctly at this point,
e.g. you may not want the program to operate on your C source code files, etc. Be careful not to destroy your own source code files!
<br>
<br>
<b>The following contains code you need to write (all in assembly language).</b>
<ol>
    <li>Starting assembly language implementation: begin with a label "code_start".</li>
    <li>Write the code for function <b style="color: red; --darkreader-inline-color: #ff1a1a;" data-darkreader-inline-color=""> void infection( )</b> that prints to
        the screen the message "Hello, Infected File".
        Note: this should be done using just one system call! If you 
		have too many lines of code here then you are doing something wrong!</li>
    <li>Write a function <b style="color: red; --darkreader-inline-color: #ff1a1a;" data-darkreader-inline-color=""> void infector(char *)</b> that does the following, in this order:
	  <ol>
	   <li> Prints the file name given as its argument
	   </li><li> Opens the file named in its argument
       </li><li> Adds the executable code from "code_start" to "code_end" after the end of that file
       </li><li> Closes the file. 
	   </li></ol>
	   Note: this should be done using just a few system calls: open (for append),
        write, close, each using less than 10 lines of assembly code. Again, if your code is longer then you are doing something wrong!</li>
    <li>End infected and infector program part with a label "code_end".</li>
 </ol>
<br>
<b>Note: it is recommended to open the file with the append option enabled (also need write of course).
You <b>may</b> open for reading/writing rather than append, but then you will have to
perform the lseek system call to the end of the file.
</b>
<br>
<br>
<b>Note for assembly language implementation:</b> The part of the code that is responsible for actual file handling
(i.e. opening the file, adding the executable code of the infection , etc.) should be written in assembly
language and done inside the file "start.s". You can add the code after the end of the code for system_call.
You can either call the system_call code (note that it uses C calling conventions, as until now you used 
it through function-calls from C),
or re-use part of it to do the system call yourself (shorter and simpler!).
Also, it is a good idea to test your infection() function first, before proceeding to infector().
<br>
<br>
Test your implementation on at least two files. You can use executable files from your previous lab solutions as input.
Use the command <b style="color: red; --darkreader-inline-color: #ff1a1a;" data-darkreader-inline-color=""> chmod u+wx {filename}</b> to give user write/execute permissions if needed.
Use hexedit to check that your infector code actually works (how?).

<h2>Submission</h2>
Task 1 and Task 2 are mandatory for this lab. 
<br>
You are required to submit a zip file named [your id].zip that contains the following:
<dt>+ task1</dt>
<dd>- start.s</dd>
<dd>- makefile</dd>
<dt>+ task2</dt>
<dd>- main.c</dd>
<dd>- start.s</dd>
<dd>- makefile</dd>

</body></html>