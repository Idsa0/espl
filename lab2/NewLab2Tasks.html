
<!-- saved from url=(0095)https://moodle.bgu.ac.il/moodle/pluginfile.php/4400679/mod_resource/content/7/NewLab2Tasks.html -->
<html data-darkreader-mode="dynamic" data-darkreader-scheme="dark"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><style class="darkreader darkreader--fallback" media="screen"></style><style class="darkreader darkreader--text" media="screen"></style><style class="darkreader darkreader--invert" media="screen">.jfk-bubble.gtx-bubble, .captcheck_answer_label > input + img, span#closed_text > img[src^="https://www.gstatic.com/images/branding/googlelogo"], span[data-href^="https://www.hcaptcha.com/"] > #icon, ::-webkit-calendar-picker-indicator, img.Wirisformula {
    filter: invert(100%) hue-rotate(180deg) contrast(90%) !important;
}</style><style class="darkreader darkreader--inline" media="screen">[data-darkreader-inline-bgcolor] {
  background-color: var(--darkreader-inline-bgcolor) !important;
}
[data-darkreader-inline-bgimage] {
  background-image: var(--darkreader-inline-bgimage) !important;
}
[data-darkreader-inline-border] {
  border-color: var(--darkreader-inline-border) !important;
}
[data-darkreader-inline-border-bottom] {
  border-bottom-color: var(--darkreader-inline-border-bottom) !important;
}
[data-darkreader-inline-border-left] {
  border-left-color: var(--darkreader-inline-border-left) !important;
}
[data-darkreader-inline-border-right] {
  border-right-color: var(--darkreader-inline-border-right) !important;
}
[data-darkreader-inline-border-top] {
  border-top-color: var(--darkreader-inline-border-top) !important;
}
[data-darkreader-inline-boxshadow] {
  box-shadow: var(--darkreader-inline-boxshadow) !important;
}
[data-darkreader-inline-color] {
  color: var(--darkreader-inline-color) !important;
}
[data-darkreader-inline-fill] {
  fill: var(--darkreader-inline-fill) !important;
}
[data-darkreader-inline-stroke] {
  stroke: var(--darkreader-inline-stroke) !important;
}
[data-darkreader-inline-outline] {
  outline-color: var(--darkreader-inline-outline) !important;
}
[data-darkreader-inline-stopcolor] {
  stop-color: var(--darkreader-inline-stopcolor) !important;
}
[data-darkreader-inline-bg] {
  background: var(--darkreader-inline-bg) !important;
}
[data-darkreader-inline-invert] {
    filter: invert(100%) hue-rotate(180deg);
}</style><style class="darkreader darkreader--variables" media="screen">:root {
   --darkreader-neutral-background: #131516;
   --darkreader-neutral-text: #d8d4cf;
   --darkreader-selection-background: #004daa;
   --darkreader-selection-text: #e8e6e3;
}</style><style class="darkreader darkreader--root-vars" media="screen"></style><style class="darkreader darkreader--user-agent" media="screen">@layer {
html {
    background-color: #181a1b !important;
}
html {
    color-scheme: dark !important;
}
iframe {
    color-scheme: initial;
}
html, body {
    background-color: #181a1b;
}
html, body {
    border-color: #736b5e;
    color: #e8e6e3;
}
a {
    color: #3391ff;
}
table {
    border-color: #545b5e;
}
mark {
    color: #e8e6e3;
}
::placeholder {
    color: #b2aba1;
}
input:-webkit-autofill,
textarea:-webkit-autofill,
select:-webkit-autofill {
    background-color: #404400 !important;
    color: #e8e6e3 !important;
}
::-webkit-scrollbar {
    background-color: #202324;
    color: #aba499;
}
::-webkit-scrollbar-thumb {
    background-color: #454a4d;
}
::-webkit-scrollbar-thumb:hover {
    background-color: #575e62;
}
::-webkit-scrollbar-thumb:active {
    background-color: #484e51;
}
::-webkit-scrollbar-corner {
    background-color: #181a1b;
}
::selection {
    background-color: #004daa !important;
    color: #e8e6e3 !important;
}
::-moz-selection {
    background-color: #004daa !important;
    color: #e8e6e3 !important;
}
}</style><meta name="darkreader" content="af927ca6e9ef48bfad1d964c953d3dd5"><style class="darkreader darkreader--override" media="screen">.vimvixen-hint {
    background-color: #7b5300 !important;
    border-color: #d8b013 !important;
    color: #f3e8c8 !important;
}
#vimvixen-console-frame {
    color-scheme: light !important;
}
::placeholder {
    opacity: 0.5 !important;
}
#edge-translate-panel-body,
.MuiTypography-body1,
.nfe-quote-text {
    color: var(--darkreader-neutral-text) !important;
}
gr-main-header {
    background-color: #0f3a48 !important;
}
.tou-z65h9k,
.tou-mignzq,
.tou-1b6i2ox,
.tou-lnqlqk {
    background-color: var(--darkreader-neutral-background) !important;
}
.tou-75mvi {
    background-color: #032029 !important;
}
.tou-ta9e87,
.tou-1w3fhi0,
.tou-1b8t2us,
.tou-py7lfi,
.tou-1lpmd9d,
.tou-1frrtv8,
.tou-17ezmgn {
    background-color: #0a0a0a !important;
}
.tou-uknfeu {
    background-color: #231603 !important;
}
.tou-6i3zyv {
    background-color: #19576c !important;
}
div.mermaid-viewer-control-panel .btn {
    background-color: var(--darkreader-neutral-background);
    fill: var(--darkreader-neutral-text);
}
svg g rect.er {
    fill: var(--darkreader-neutral-background) !important;
}
svg g rect.er.entityBox {
    fill: var(--darkreader-neutral-background) !important;
}
svg g rect.er.attributeBoxOdd {
    fill: var(--darkreader-neutral-background) !important;
}
svg g rect.er.attributeBoxEven {
    fill: var(--darkreader-selection-background);
    fill-opacity: 0.8 !important;
}
svg rect.er.relationshipLabelBox {
    fill: var(--darkreader-neutral-background) !important;
}
svg g g.nodes rect,
svg g g.nodes polygon {
    fill: var(--darkreader-neutral-background) !important;
}
svg g rect.task {
    fill: var(--darkreader-selection-background) !important;
}
svg line.messageLine0,
svg line.messageLine1 {
    stroke: var(--darkreader-neutral-text) !important;
}
div.mermaid .actor {
    fill: var(--darkreader-neutral-background) !important;
}
.google-material-icons {
    font-family: 'Google Material Icons' !important;
}
.google-symbols {
    font-family: 'Google Symbols Subset', 'Google Symbols' !important;
}
.material-icons-extended {
    font-family: 'Material Icons Extended' !important;
}
mitid-authenticators-code-app > .code-app-container {
    background-color: white !important;
    padding-top: 1rem;
}
iframe#unpaywall[src$="unpaywall.html"] {
    color-scheme: light !important;
}
.oui-icon {
    font-family: 'Oui Icons' !important;
}</style></head><body>
<h1> lab 2 </h1>
In this lab, you should perform <b> task 0 before attending the lab session</b>.
This lab should be done and submitted solo.
<h2 id="goals">Goals</h2>
<ul>
<li> Get acquainted with command interpreters ("shell") by implementing a simple command interpreter.
</li><li> Understand how Unix/Linux fork() and exec() work.
</li><li> Introduction to Linux signals.
</li><li> Redirection, and introduction to pipes.
</li><li> Learn how to read the manual (man).
</li></ul>
<br>
<div class="info"><b>Note</b><br>
You will be extending your code from lab 2 for use in lab C, so try make your code readable and modular.
</div>
<p></p><p>
</p><hr>
<h2 id="motivation">Motivation</h2>
<p> Perhaps the most important system program is the <b>command
interpreter</b>, that is, the program that gets user commands and
executes them. The command interpreter is thus the major interface
between the user and the operating system services. There are two main
types of command interpreters: </p>
<ul>
  <li> Command-line interpreters, which receive user commands in text form and execute them (also called <b>shell</b> in UNIX-like systems). </li>
  <li> Menu-based interpreters, where the user selects commands from a menu. At the most basic level, menus are text driven. At the most extreme end, everything is wrapped in a nifty graphical display (e.g. Windows or KDE command interpreters). </li>
<p></p><p>
</p></ul>
<h3 id="lab_goals">Lab Goals</h3>
In this sequence of labs (2 and C), you will be implementing a simple shell (command-line interpreter). Like traditional UNIX shells, your shell program will <b>also</b> be a <b>user level</b> process (just like all your programs to-date), that will rely heavily on the operating system's services. Your shell should do the following:
<ul>
  <li> Receive commands from the user. </li>
  <li> Interpret the commands, and use the operating system to help starting up programs and processes requested by the user. </li>
  <li> Manage process execution (e.g. run processes in the background, suspend them, etc.), using the operating system's services. </li>
</ul>
<p> The complicated tasks of actually starting up the processes, mapping
their memory, files, etc. are strictly a responsibility of the
operating system, and as such you will study these issues in the
Operating Systems course. Your responsibility, therefore, is limited to telling the operating system which
processes to run, how to run these processes (run in the background/foreground) etc.</p>
<p> Starting and maintaining a process involves many technicalities, and like any other command interpreter we will get assistance from system calls, such as <font color="green" data-darkreader-inline-color="" style="--darkreader-inline-color: #72ff72;"> execv, fork, waitpid </font> (see <b>man</b> on how to use these system calls).<br>
</p>
<h2 id="lab_2_tasks">lab 2 tasks</h2>
First, download <a href="https://moodle.bgu.ac.il/moodle/pluginfile.php/3724005/mod_resource/content/1/LineParser.c">LineParser.c</a> and <a href="https://moodle.bgu.ac.il/moodle/pluginfile.php/3724006/mod_resource/content/2/LineParser.h">LineParser.h</a>.
These files contain some useful parsing and string management functions that will simplify your 
code substantially. Make sure you appropriately refer to LineParser.c in your makefile. You can find a detailed explanation in the reading material for lab 2.
<div class="warning">
Throughout the lab pay close attention to the difference between <b>processes</b>(things that you run with
execvp() after fork()) and <b>shell commands</b>. Think about when do you need a new process and when 
to use the process of the shell. 
Running things in a different process preserves inter-activeness with the shell. However, not all things can be run in a new process.
</div>
<h3 id="task_0a"><font size="+1"> Task 0a </font></h3>
Here you are required to write a basic shell program <b>myshell</b>. 
Keep in mind that you are expected to extend this basic shell during the next tasks.
In your code write an infinite loop and carry out the following:
<p></p><p>
</p><ol>
  <li> Display a prompt - the current working directory (see man getcwd). The path name is not expected to
 exceed <b>PATH_MAX</b> (it's defined in <b>linux/limits.h</b>, so you'll need to include it).
</li>
  <li> Read a line from the "user", i.e. from stdin (no more than 2048 bytes). It is advisable to use <b>fgets</b> (see man).
</li>
  <li> Parse the input using <b>parseCmdLines()</b> (LineParser.h).
The result is a structure <b>cmdLine</b> that contains all necessary parsed data.
</li>
  <li> Write a function <b>execute(cmdLine *pCmdLine)</b> that receives a parsed line and invokes
the program specified in the cmdLine using the proper system call (see man <b>execv</b>).
</li>
  <li> Use <b>perror</b> (see man) to display an error if the execv fails, and then exit "abnormally".
</li>
<li> Release the cmdLine resources when finished.
</li>
  <li> End the infinite loop of the shell if the command "quit" is entered in the shell, and exit the shell "normally".
</li>
</ol>
<br>
Once you execute your program, you will notice a few things:
<ul>
  <li> Although you loop infinitely, the execution ends after execv. Why is that?
</li>
  <li> You must place the full path of an executable file in-order to run properly.
For instance: "ls" won't work, whereas "/bin/ls" runs properly. (Why?)
<br>
</li></ul>
<br>
<b>Now replace execv with execvp (see man) and try again </b>.
<ul>
<p></p><p>
</p><li> Wildcards, as in "ls *", are not working. (Again, why?)
</li>
</ul>
<br>
In addition to the reading material, please make sure you read up on and understand the system calls: fork(2),
 exec(2) and its variants, signal(2), and waitpid(2), before attending the "official" lab session.
<h3 id="task_0b"><font size="+1"> Task 0b </font></h3>
<p></p><p>
Add the signal handler <a href="https://moodle.bgu.ac.il/moodle/pluginfile.php/3724008/mod_resource/content/1/looper.c">looper.c</a> 
that prints the signal with a message saying it was received, and propagates the signal 
to the default signal handler. This is what really makes the process sleep/continue. 
The signals you need to address are: SIGTSTP, SIGINT, SIGCONT. The signals will be sent to the looper by the shell 
that you are going to write to test the functionality of the signal commands in task 3 and the process 
manager that you are going to implement in lab C. <br>
</p><ul>
<li> Use strsignal (see: <code class="code">man strsignal</code>) to get the signal name.
</li><li> See signal(2) you will need it to set your handler to handle these signals. 
</li><li> Use signal(signum, SIG_DFL) to make the default handler handle the signal.
</li><li> Use raise() to send the signal again, so that the default signal handler can handle it. 
<p></p><p>
</p></li><li> After handling SIGCONT, make sure you reinstate the custom handler for SIGTSTP
</li><li> After handling SIGTSTP, make sure you reinstate the custom handler for SIGCONT
</li></ul>
<br>
<hr><h3 id="task_1"><font size="+1"> Task 1 </font></h3>
In this task, you will make your shell work like a real command interpreter (tasks 1a and 1b), and then add various features.<br>
When executed with the "-d" flag, your shell will also print the debug output to stderr (if "-d" is not given, you should not print
anything to stderr).
<h3 id="task_1a"><font size="+1"> Task 1a </font></h3>
Building up on your code from task 0, we would like our shell to remain active after invoking another program. 
The <b> fork </b> system call (see man) is the key: it 'duplicates' our process, 
creating an almost identical copy (<b>child</b>)
of the issuing (<b>parent</b>) process. 
For the parent process, the call returns the process ID of the newly-born child, whereas for
the child process - the value 0 is returned. 
<p></p><p>
</p><div class="info"><b>You will need to print to <code>stderr</code> the following debug information in your task:</b><br>
<p></p><p>
</p><ul>
<li> PID </li>
<li> Executing command </li>
</ul>
</div>
<p></p><p>
Notes:
</p><ul>
<li> Use fork to maintain the shell alive (recall mandatory lecture 2) by forking before <b>execvp</b>,
while handling the return code 
appropriately (again as stated in the lecture). (Although if fork( ) fails you are 
in real trouble anyway (e.g. fork bomb!), so you might as well ignore this case).
</li>
  <li> If execvp fails, use <b>_exit()</b> (see man) to terminate the process. (Why?)
</li>
</ul>
<h3 id="task_1b"><font size="+1"> Task 1b </font></h3>

Until now we've executed commands without waiting for the process to terminate.
You will now use the <b>waitpid</b> call (see man), in order to implement the wait. 
Pay attention to the <b>blocking</b> field in cmdLine. 
It is set to 0 if a "&amp;" symbol is added at the end of the line, 1 otherwise.<br><br>
Invoke waitpid when you're required, and only when you're required. For example: "cat myshell.c &amp;" will not wait for the cat process to end (cat in this case runs in the <b>background</b>), but "cat myshell.c" will (cat runs in the <b>foreground</b>). 
<p></p><p>

</p><h3 id="task_1c"><font size="+1"> Task 1c </font></h3>
Add a <b>shell command</b> "cd" that allows the user to change the current working directory.
Essentially, you need to emulate a simplified version of the "cd" internal shell command: use <b>chdir</b> 
for that purpose (see man). No need to implement anything beyond transferring the argument of "cd" to "chdir".
<b>Print appropriate error message to stderr if the cd operation fails.</b>
Note that for interal shell commands, like this feature, your shell should <bf> not </bf> create a child process.
<p></p>



<h3 id="task_2_-_signals"><font size="+1"> Task 2 - Signals  </font></h3>
Every program you run using the shell runs as a process. You can get a list of the running processes using the <code class="code">ps</code> program
(see: <code class="code">man 1 ps</code> and <code class="code">man 2 ps</code>).

In this task we are going to implement internal shell commands to help manage the processes using signals. Implement and test the
following commands:

<li> <code class="code">alarm &lt;process id&gt;</code> - Wake up a sleeping process (SIGCONT).
</li><li> <code class="code">blast &lt;process id&gt;</code> - Terminate a running/sleeping process.
</li>
<br>

In both cases, use the kill( ) system call wrapper, see man 2 kill, to send the relevant signal to the given process id. 
Check if kill( ) succeeded and print an appropriate message.<br>
<p></p><p>
Test your shell using your <code class="code">looper</code> code from task0b in the following scenario: 
</p><p>
</p><pre class="code">#&gt; ./looper&amp;
#&gt; ./looper&amp;
#&gt; ./looper&amp;
#&gt; ps
PID TTY          TIME CMD
17998 pts/11   00:00:00 bash
24207 pts/11   00:00:00 task2
24246 pts/11   00:00:00 looper
24279 pts/11   00:00:00 looper
24326 pts/11   00:00:00 looper
24336 pts/11   00:00:00 ps
#&gt; blast 24326
#&gt; ps
PID TTY          TIME CMD
17998 pts/11   00:00:00 bash
24207 pts/11   00:00:00 task2
24246 pts/11   00:00:00 looper
24279 pts/11   00:00:00 looper
24326 pts/11   00:00:00 looper &lt;defunct&gt;
24336 pts/11   00:00:00 ps

</pre>
<p>

</p><h3 id="task_3_-_redirect"><font size="+1"> Task 3: Redirection  </font></h3>

<p>Add standard input/output redirection capabilities to your shell (e.g.,&nbsp;<br> <strong>"cat &lt; in.txt &gt; out.txt"</strong>). 
Guidelines on I/O redirection can be found in the reading material.<br> <br> Notes:</p>
<ul>
<li>The&nbsp;<strong>inputRedirect</strong>&nbsp;and&nbsp;<strong>outputRedirect</strong>&nbsp;fields in 
cmdLine do the parsing work for you. They hold the redirection file names if exist, NULL otherwise.</li>
<li>Remember to redirect input/output only in the child process. We do not want to redirect the I/O of the shell itself (parent process).</li>
</ul>

<p>
</p><div class="warning">
<b><span style="font-size:120%">Now that you finished tasks 1, 2, 3, save your code aside. You will need it for submission and for
Lab C.</span></b>
</div>


<h3 id="task_4_-_pipes"><font size="+1"> Task 4: Exercise in Pipe System Call </font></h3>

<p>Recall from the lecture that a pipe is a pair of input stream/output stream, such that one stream feeds the other stream directly. 
All data that is 
written to one side (the "write end") can be read from the other side (the "read end"). This sort of feed becomes pretty 
useful when one wishes to communicate between processes, such as when implementing a shell pipe
as described in the lecture. This task is to help you execise the basic pipe mechanism,
towards achieving a shell pipe implementation (part of what you will be doing in lab C).<br> <br> <strong>Your task:</strong>&nbsp;Implement a simple 
program called&nbsp;<strong>mypipe</strong> (a program <b> separate</b> from your shell), which creates a child process that 
sends a message such as "hello" to its parent process. 
The parent then prints the incoming message and terminates. Use the&nbsp;<strong>pipe</strong>&nbsp;system call
(see man) to create the pipe.</p>


<h2 id="deliverables"> Deliverables: lab 2 </h2>

Tasks 1, 2, 3 must be completed during the regular lab. The deliverables must be submitted until the end of the lab session.<br>
Task 4 is needed to help you understand pipes, and we recommend that you also finish and test it with a TA,
but is not required for a full grade in the lab.
<p>

You must submit 1 source file, a shell including tasks 1, 2, 3: <br>
Name it myshell.c<br>
Also, submit a makefile that compiles and links myshell.
<br>
</p><h4> Submission instructions</h4>
<ul>
<li>
Create a zip file with the relevant files (only) (named [student-id-num].zip)
</li>
<li>
Upload zip file to the submission system.
</li>
<li>
Download the zip file from the submission system and extract its content to an empty folder.
</li>
<li>
Compile and test the code to make sure that it still works.
</li>
</ul>
<br>
</body></html>