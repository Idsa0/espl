
<!-- saved from url=(0098)https://moodle.bgu.ac.il/moodle/pluginfile.php/4400678/mod_resource/content/11/Lab2ReadingNew.html -->
<html data-darkreader-mode="dynamic" data-darkreader-scheme="dark"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><style class="darkreader darkreader--fallback" media="screen"></style><style class="darkreader darkreader--text" media="screen"></style><style class="darkreader darkreader--invert" media="screen">.jfk-bubble.gtx-bubble, .captcheck_answer_label > input + img, span#closed_text > img[src^="https://www.gstatic.com/images/branding/googlelogo"], span[data-href^="https://www.hcaptcha.com/"] > #icon, ::-webkit-calendar-picker-indicator, img.Wirisformula {
    filter: invert(100%) hue-rotate(180deg) contrast(90%) !important;
}</style><style class="darkreader darkreader--inline" media="screen">[data-darkreader-inline-bgcolor] {
  background-color: var(--darkreader-inline-bgcolor) !important;
}
[data-darkreader-inline-bgimage] {
  background-image: var(--darkreader-inline-bgimage) !important;
}
[data-darkreader-inline-border] {
  border-color: var(--darkreader-inline-border) !important;
}
[data-darkreader-inline-border-bottom] {
  border-bottom-color: var(--darkreader-inline-border-bottom) !important;
}
[data-darkreader-inline-border-left] {
  border-left-color: var(--darkreader-inline-border-left) !important;
}
[data-darkreader-inline-border-right] {
  border-right-color: var(--darkreader-inline-border-right) !important;
}
[data-darkreader-inline-border-top] {
  border-top-color: var(--darkreader-inline-border-top) !important;
}
[data-darkreader-inline-boxshadow] {
  box-shadow: var(--darkreader-inline-boxshadow) !important;
}
[data-darkreader-inline-color] {
  color: var(--darkreader-inline-color) !important;
}
[data-darkreader-inline-fill] {
  fill: var(--darkreader-inline-fill) !important;
}
[data-darkreader-inline-stroke] {
  stroke: var(--darkreader-inline-stroke) !important;
}
[data-darkreader-inline-outline] {
  outline-color: var(--darkreader-inline-outline) !important;
}
[data-darkreader-inline-stopcolor] {
  stop-color: var(--darkreader-inline-stopcolor) !important;
}
[data-darkreader-inline-bg] {
  background: var(--darkreader-inline-bg) !important;
}
[data-darkreader-inline-invert] {
    filter: invert(100%) hue-rotate(180deg);
}</style><style class="darkreader darkreader--variables" media="screen">:root {
   --darkreader-neutral-background: #131516;
   --darkreader-neutral-text: #d8d4cf;
   --darkreader-selection-background: #004daa;
   --darkreader-selection-text: #e8e6e3;
}</style><style class="darkreader darkreader--root-vars" media="screen"></style><style class="darkreader darkreader--user-agent" media="screen">@layer {
html {
    background-color: #181a1b !important;
}
html {
    color-scheme: dark !important;
}
iframe {
    color-scheme: initial;
}
html, body {
    background-color: #181a1b;
}
html, body {
    border-color: #736b5e;
    color: #e8e6e3;
}
a {
    color: #3391ff;
}
table {
    border-color: #545b5e;
}
mark {
    color: #e8e6e3;
}
::placeholder {
    color: #b2aba1;
}
input:-webkit-autofill,
textarea:-webkit-autofill,
select:-webkit-autofill {
    background-color: #404400 !important;
    color: #e8e6e3 !important;
}
::-webkit-scrollbar {
    background-color: #202324;
    color: #aba499;
}
::-webkit-scrollbar-thumb {
    background-color: #454a4d;
}
::-webkit-scrollbar-thumb:hover {
    background-color: #575e62;
}
::-webkit-scrollbar-thumb:active {
    background-color: #484e51;
}
::-webkit-scrollbar-corner {
    background-color: #181a1b;
}
::selection {
    background-color: #004daa !important;
    color: #e8e6e3 !important;
}
::-moz-selection {
    background-color: #004daa !important;
    color: #e8e6e3 !important;
}
}</style><meta name="darkreader" content="965c7160abda4ee99606aa3ba56814df"><style class="darkreader darkreader--override" media="screen">.vimvixen-hint {
    background-color: #7b5300 !important;
    border-color: #d8b013 !important;
    color: #f3e8c8 !important;
}
#vimvixen-console-frame {
    color-scheme: light !important;
}
::placeholder {
    opacity: 0.5 !important;
}
#edge-translate-panel-body,
.MuiTypography-body1,
.nfe-quote-text {
    color: var(--darkreader-neutral-text) !important;
}
gr-main-header {
    background-color: #0f3a48 !important;
}
.tou-z65h9k,
.tou-mignzq,
.tou-1b6i2ox,
.tou-lnqlqk {
    background-color: var(--darkreader-neutral-background) !important;
}
.tou-75mvi {
    background-color: #032029 !important;
}
.tou-ta9e87,
.tou-1w3fhi0,
.tou-1b8t2us,
.tou-py7lfi,
.tou-1lpmd9d,
.tou-1frrtv8,
.tou-17ezmgn {
    background-color: #0a0a0a !important;
}
.tou-uknfeu {
    background-color: #231603 !important;
}
.tou-6i3zyv {
    background-color: #19576c !important;
}
div.mermaid-viewer-control-panel .btn {
    background-color: var(--darkreader-neutral-background);
    fill: var(--darkreader-neutral-text);
}
svg g rect.er {
    fill: var(--darkreader-neutral-background) !important;
}
svg g rect.er.entityBox {
    fill: var(--darkreader-neutral-background) !important;
}
svg g rect.er.attributeBoxOdd {
    fill: var(--darkreader-neutral-background) !important;
}
svg g rect.er.attributeBoxEven {
    fill: var(--darkreader-selection-background);
    fill-opacity: 0.8 !important;
}
svg rect.er.relationshipLabelBox {
    fill: var(--darkreader-neutral-background) !important;
}
svg g g.nodes rect,
svg g g.nodes polygon {
    fill: var(--darkreader-neutral-background) !important;
}
svg g rect.task {
    fill: var(--darkreader-selection-background) !important;
}
svg line.messageLine0,
svg line.messageLine1 {
    stroke: var(--darkreader-neutral-text) !important;
}
div.mermaid .actor {
    fill: var(--darkreader-neutral-background) !important;
}
.google-material-icons {
    font-family: 'Google Material Icons' !important;
}
.google-symbols {
    font-family: 'Google Symbols Subset', 'Google Symbols' !important;
}
.material-icons-extended {
    font-family: 'Material Icons Extended' !important;
}
mitid-authenticators-code-app > .code-app-container {
    background-color: white !important;
    padding-top: 1rem;
}
iframe#unpaywall[src$="unpaywall.html"] {
    color-scheme: light !important;
}
.oui-icon {
    font-family: 'Oui Icons' !important;
}</style></head><body><h1>Labs 2: Reading Material<sup class="edit-section" id="section-6"></sup></h1>
<h2 id="implementing_a_command_interpreter_shell">Implementing a Command Interpreter (Shell)<sup class="edit-section" id="section-6"></sup></h2>
You should read the introductory material from the task descriptions as
part of the reading material.<br>
Download the attached code in the task file and learn 
how to use it.
<p>Thoroughly understand the following:
</p>
<ol>
  <li>All the material from previous labs related to the C language,
especially using pointers and structures in C. </li>
  <li>Read the man pages and understand how to use the following system
calls and library functions: getcwd, fork, execv, execvp, perror, waitpid, pipe, dup, 
open, close.</li>
<p></p><p>
</p></ol>
Basic introduction to the notion of fork can be found&nbsp;<a href="https://en.wikipedia.org/wiki/Fork_(system_call)">here.</a>

<br>
<h2 id="attached_code_documentation"> Attached code documentation <sup class="edit-section" id="section-6"></sup></h2>
<h4> LineParser: </h4>
<p>
This package supports parsing of a given string to a structure which holds all the necessary data for a shell program.
<br>For instance, parsing the string <b>"cat file.c &gt; output.txt &amp;"</b> results in a cmdLine struct, consisting of arguments = {"cat", "file.c"}, outputRedirect = "output.txt", blocking = 0 etc.
<br><br>
</p><p>
<textarea name="textarea" readonly="readonly" cols="110" rows="10">typedef struct cmdLine
{
    char * const arguments[MAX_ARGUMENTS]; 
    int argCount;		
    char const *inputRedirect;	
    char const *outputRedirect;	
    char blocking;	
    int idx;		
    struct cmdLine* next;	 
} cmdLine;
</textarea>
</p><p>
</p><hr>
<p> Included functions: </p>
<ol>
<li> <b>cmdLine* parseCmdLines(const char *strLine) </b><br>
Returns a parsed structure cmdLine from a given strLine string, NULL 
when there was nothing to parse.
If the strLine indicates a pipeline (e.g. "ls | grep x"), the function 
will return a linked list of cmdLine structures, as indicated by the <b>next</b> field. </li> <br>
<li> <b>void freeCmdLines(cmdLine *pCmdLine)</b> <br>
Releases the memory that was allocated to accomodate the linked list of cmdLines, starting with the head of the list pCmdLine.
</li><br>
<li> <b>int replaceCmdArg(cmdLine *pCmdLine, int num, const char *newString)</b> <br>
Replaces the argument with index <i>num</i> in the arguments field of pCmdLine with a given string.<br>
If successful returns 1, otherwise - returns 0. </li>
</ol>
<hr>
<br>

 <h3>Standard Input/Output Redirection</h3>
    <p>Standard input and output are the "natural" feed (input) and sink (output) streams of a program: 
	User input is read from the keyboard, and the program's output is displayed on monitor. However, in many cases 
	one would like to read input from a file, rather than from keyboard. Similarly, one may wish to store the output in a file, 
	rather than display it on a monitor. Both requirements can be met by standard input/output redirection, without changing the
	code of the original program.
    </p>
    
    <p>As a convention, input redirection is triggered by adding &lt; after the invoked command. For instance, "cat &lt; my.txt" tells 
	the shell program to redirect the input of cat to be from file my.txt. As a result, cat displays the content of my.txt instead of 
	displaying user feed from the keyboard. Output is triggered by adding "&gt;", for instance: "ls &gt; out.txt" which stores the list of files in the 
	current directory in out.txt. Combining input and output redirection is also possible, e.g. "cat &lt; my.txt &gt; yours.txt", which stores the content 
	of my.txt in yours.txt.
    </p>
    
      <p>How does the shell program achieve such an effect? Simply by closing the standard input stream (file descriptor 0)
	  or the standard output stream (file descriptor 1), and opening a new file, which in turn is automatically allocated with the lowest 
	  available file-descriptor index. This effectively overrides stdin or stdout.
    </p>
    
<!--?if(CSWML_TagElement_SECURE::is_secure()){?--><div class="secure">
<h3>Job Control<sup class="edit-section" id="section-4"></sup></h3>
Processes belonging to a single command are referred to as a
 <a href="https://en.wikipedia.org/wiki/Process_group" class="external" rel="nofollow">job or a process group</a>. For
 example, <code class="code">ls|wc -l</code> both the process that runs <code class="code">ls</code> and the
 process that runs <code class="code">wc -l</code> of this command belong to the same job/process group. Only one process 
 group can run in the foreground and control the shell, the terminal's process group is set using tcsetpgrp. 
 The rest of the process groups run in the background. Deciding which jobs  run in the background and which run
 in the foreground is called job control. You can read more about job control in the 
 following link: <a href="https://tiswww.case.edu/php/chet/bash/bashref.html#Job-Control" class="external" rel="nofollow">link1</a>.
<p></p>

<p>
</p></div>
<h3 id=""><a href="https://en.wikipedia.org/wiki/Unix_signal" class="external" rel="nofollow">Signals</a>
<sup class="edit-section" id="section-6"></sup></h3>
Signals are a used to send asynchronous events to a program such as ctrl-c, and ctrl-z. You can read more about 
signals <a href="http://www.thegeekstuff.com/2012/03/linux-signals-fundamentals/" class="external" rel="nofollow">here</a> and <a href="http://www.thegeekstuff.com/2011/02/send-signal-to-process/" class="external" rel="nofollow">here</a>.
<h2 id="man_relevant_functions_and_utilities"> MAN: Relevant Functions and Utilities<sup class="edit-section" id="section-6"></sup></h2>
fork(2), wait(2), waitpid(2), _exit, exit(3), close(2), open(2), read(2), write(2), getpid(2), setpgid(2), tcsetpgrp(3), tcgetpgrp(3), kill(2), signal(2), pipe(2).</body></html>