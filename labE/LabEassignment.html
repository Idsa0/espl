
<!-- saved from url=(0106)https://moodle.bgu.ac.il/moodle/pluginfile.php/4400718/mod_resource/content/17/LabEassignment.html?embed=1 -->
<html data-darkreader-mode="dynamic" data-darkreader-scheme="dark" data-darkreader-proxy-injected="true"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><style class="darkreader darkreader--fallback" media="screen"></style><style class="darkreader darkreader--text" media="screen"></style><style class="darkreader darkreader--invert" media="screen">.jfk-bubble.gtx-bubble, .captcheck_answer_label > input + img, span#closed_text > img[src^="https://www.gstatic.com/images/branding/googlelogo"], span[data-href^="https://www.hcaptcha.com/"] > #icon, ::-webkit-calendar-picker-indicator, img.Wirisformula {
    filter: invert(100%) hue-rotate(180deg) contrast(90%) !important;
}</style><style class="darkreader darkreader--inline" media="screen">[data-darkreader-inline-bgcolor] {
  background-color: var(--darkreader-inline-bgcolor) !important;
}
[data-darkreader-inline-bgimage] {
  background-image: var(--darkreader-inline-bgimage) !important;
}
[data-darkreader-inline-border] {
  border-color: var(--darkreader-inline-border) !important;
}
[data-darkreader-inline-border-bottom] {
  border-bottom-color: var(--darkreader-inline-border-bottom) !important;
}
[data-darkreader-inline-border-left] {
  border-left-color: var(--darkreader-inline-border-left) !important;
}
[data-darkreader-inline-border-right] {
  border-right-color: var(--darkreader-inline-border-right) !important;
}
[data-darkreader-inline-border-top] {
  border-top-color: var(--darkreader-inline-border-top) !important;
}
[data-darkreader-inline-boxshadow] {
  box-shadow: var(--darkreader-inline-boxshadow) !important;
}
[data-darkreader-inline-color] {
  color: var(--darkreader-inline-color) !important;
}
[data-darkreader-inline-fill] {
  fill: var(--darkreader-inline-fill) !important;
}
[data-darkreader-inline-stroke] {
  stroke: var(--darkreader-inline-stroke) !important;
}
[data-darkreader-inline-outline] {
  outline-color: var(--darkreader-inline-outline) !important;
}
[data-darkreader-inline-stopcolor] {
  stop-color: var(--darkreader-inline-stopcolor) !important;
}
[data-darkreader-inline-bg] {
  background: var(--darkreader-inline-bg) !important;
}
[data-darkreader-inline-invert] {
    filter: invert(100%) hue-rotate(180deg);
}</style><style class="darkreader darkreader--variables" media="screen">:root {
   --darkreader-neutral-background: #131516;
   --darkreader-neutral-text: #d8d4cf;
   --darkreader-selection-background: #004daa;
   --darkreader-selection-text: #e8e6e3;
}</style><style class="darkreader darkreader--root-vars" media="screen"></style><style class="darkreader darkreader--user-agent" media="screen">@layer {
html {
    background-color: #181a1b !important;
}
html {
    color-scheme: dark !important;
}
iframe {
    color-scheme: initial;
}
html, body {
    background-color: #181a1b;
}
html, body {
    border-color: #736b5e;
    color: #e8e6e3;
}
a {
    color: #3391ff;
}
table {
    border-color: #545b5e;
}
mark {
    color: #e8e6e3;
}
::placeholder {
    color: #b2aba1;
}
input:-webkit-autofill,
textarea:-webkit-autofill,
select:-webkit-autofill {
    background-color: #404400 !important;
    color: #e8e6e3 !important;
}
::-webkit-scrollbar {
    background-color: #202324;
    color: #aba499;
}
::-webkit-scrollbar-thumb {
    background-color: #454a4d;
}
::-webkit-scrollbar-thumb:hover {
    background-color: #575e62;
}
::-webkit-scrollbar-thumb:active {
    background-color: #484e51;
}
::-webkit-scrollbar-corner {
    background-color: #181a1b;
}
::selection {
    background-color: #004daa !important;
    color: #e8e6e3 !important;
}
::-moz-selection {
    background-color: #004daa !important;
    color: #e8e6e3 !important;
}
}</style><meta name="darkreader" content="4d5c805c890b4612a2891fc49185bef0"><style class="darkreader darkreader--override" media="screen">.vimvixen-hint {
    background-color: #7b5300 !important;
    border-color: #d8b013 !important;
    color: #f3e8c8 !important;
}
#vimvixen-console-frame {
    color-scheme: light !important;
}
::placeholder {
    opacity: 0.5 !important;
}
#edge-translate-panel-body,
.MuiTypography-body1,
.nfe-quote-text {
    color: var(--darkreader-neutral-text) !important;
}
gr-main-header {
    background-color: #0f3a48 !important;
}
.tou-z65h9k,
.tou-mignzq,
.tou-1b6i2ox,
.tou-lnqlqk {
    background-color: var(--darkreader-neutral-background) !important;
}
.tou-75mvi {
    background-color: #032029 !important;
}
.tou-ta9e87,
.tou-1w3fhi0,
.tou-1b8t2us,
.tou-py7lfi,
.tou-1lpmd9d,
.tou-1frrtv8,
.tou-17ezmgn {
    background-color: #0a0a0a !important;
}
.tou-uknfeu {
    background-color: #231603 !important;
}
.tou-6i3zyv {
    background-color: #19576c !important;
}
div.mermaid-viewer-control-panel .btn {
    background-color: var(--darkreader-neutral-background);
    fill: var(--darkreader-neutral-text);
}
svg g rect.er {
    fill: var(--darkreader-neutral-background) !important;
}
svg g rect.er.entityBox {
    fill: var(--darkreader-neutral-background) !important;
}
svg g rect.er.attributeBoxOdd {
    fill: var(--darkreader-neutral-background) !important;
}
svg g rect.er.attributeBoxEven {
    fill: var(--darkreader-selection-background);
    fill-opacity: 0.8 !important;
}
svg rect.er.relationshipLabelBox {
    fill: var(--darkreader-neutral-background) !important;
}
svg g g.nodes rect,
svg g g.nodes polygon {
    fill: var(--darkreader-neutral-background) !important;
}
svg g rect.task {
    fill: var(--darkreader-selection-background) !important;
}
svg line.messageLine0,
svg line.messageLine1 {
    stroke: var(--darkreader-neutral-text) !important;
}
div.mermaid .actor {
    fill: var(--darkreader-neutral-background) !important;
}
mitid-authenticators-code-app > .code-app-container {
    background-color: white !important;
    padding-top: 1rem;
}
iframe#unpaywall[src$="unpaywall.html"] {
    color-scheme: light !important;
}</style></head><body><h1>Lab E: Linking ELF Object Files</h1>
<div class="info">
This lab may be done either solo or in pairs.
</div>
<p>
In the previous lab, you learned to investigate and change ELF files using hexedit, and other command-line tools.
 In this lab, you will continue to manipulate ELF files, this time using your own code (written in C), and perform a limited pass I
 operation of the linkage editor ("linker").<br>
</p><p>
We will parse the ELF file and extract useful information from it. In particular, we will access the 
data in the section header table, and in the symbol table.
We will also learn to use the <tt>mmap</tt> system call.
</p><h3 id="important">Important</h3>
This lab is written for 32-bit machines. Some of the computers in the labs already run on a 
64-bit OS (use<i> uname -a</i> to see if the linux OS is 64-bit or not). 32-bit and 64-bit machines have different 
instruction sets and different memory layout. Make sure to include the <i>-m32</i> flag when you compile files, 
and to use the Elf32 data structures (and not the Elf64 ones).<br>
<p></p><p>
In order to know if an executable file is compiled for 64-bit or 32-bit platform, you can use readelf, 
or the <i>file</i> command-line tool (for example: <code class="code">file /bin/ls</code>).
</p><p>
</p><div class="tip">
<h3 id="useful_tips">Useful Tips</h3>
You will no longer be using <i>hexedit</i> to process the file and strings to find the information; nevertheless, in some cases you may still want to use these tools for debugging purposes. In order to take advantage of these tools and make your tasks easier, you should:<br>
<ul>
  <li>   Print debugging messages: in particular the offsets of the various items, as you discover them from the headers.
  </li><li>   Use <i>hexedit</i> and <i>readelf</i> to compare the information you are looking for, especially if you run into unknown problems. <i>hexedit</i> is great if you know the exact location of the item you are looking for.
  </li><li>   Note that while the object files you will be processing will be linked using <i>ld</i>, and will, in most cases, use direct system calls in order to make the ELF file simpler, there is no reason why the programs you write need use this interface. You are allowed to use the standard library when building your own C programs.
  </li><li>   In order to preserve your sanity, even if the code you MANIPULATE may be without stdlib, we advise that for your OWN CODE you DO use the C standard library!
  </li><li>   In order to keep sane in the following lab as well, <b>understand</b> what you are doing and <b>keep track</b> of that and of your code, as you will be using them in a future lab. 
</li></ul>
</div>
<h2 id="lab_E_tasks">Lab E Assignment</h2>

<p>The goal of this lab is to implement a limited pass I (merging) of a linkage editor.
You begin by allowing access to ELF object files, examining, and printing out their structures (section headers and symbol table).
After this part is correctly implemented and debugged, you will be implementing the part that does the merging.
This assignment will be limited to merging 2 ELF files, and with additional simplifying assumptions and restrictions
specified later on.</p>

<div class="warning">
You must use only the <tt>mmap</tt> system call to read data from your ELF files from this point onwards.
However, you should use write( ) to generate the merged output file.
</div>


<h2 id="part_0">Part 0</h2>

<p></p><p>
This part is about learning to use the <tt>mmap</tt> system call.
Read about the <tt>mmap</tt> system call (<code class="code">man mmap</code>).
</p><p>
Write a program that uses the <tt>mmap</tt> to examine the header of a 32-bit ELF file (include 
and use the structures in elf.h). The program is first activated as:
</p><p>
</p><pre class="code">  myELF
</pre>

<p></p><p>
The program then uses a menu similar to lab 4, with available operations, as follows:
</p><pre class="code">Choose action:
0-Toggle Debug Mode
1-Examine ELF File
2-Print Section Names
3-Print Symbols
4-Check Files for Merge
5-Merge ELF Files
6-Quit
</pre>

<p></p><p>
Note that the menu should use the same technique as in lab 1, i.e. an array of structures of available options.
Toggle Debug Mode is as in Lab 4. Quit should unmap and close any mapped or open files, and "exit normally".
Examine ELF Files queries the user for an ELF file name(s)
to be used and examined henceforth. For now, options 2, 3, 4, 5, should call stub functions
that print "not implemented yet".
All file input should be read using the <tt>mmap</tt> system call. You are NOT ALLOWED to 
use <tt>read</tt>, or <tt>fread</tt>.
</p><p>
</p><div class="tip">
To make your life easier throughout the lab, for each ELF file, map the entire file with one <tt>mmap</tt> call.
</div>
<p></p>
<p>
The <i>examine</i> ELF file option should print the following information from the header.
</p><p>
</p><ol>
<li>    Bytes 1,2,3 of the magic number (in ASCII). Henceforth, you should check that the number is consistent with an ELF file, and refuse to continue if it is not.
</li><li>    The data encoding scheme of the object file.
</li><li>    Entry point (hexadecimal address).
</li><li>    The file offset in which the section header table resides.
</li><li>    The number of section header entries.
</li><li>    The size of each section header entry.
</li><li>    The file offset in which the program header table resides.
</li><li>    The number of program header entries.
</li><li>    The size of each program header entry.
</li></ol>
<br>
<p>
The above information should be printed in the above exact order (print it out as nicely as <i>readelf</i> does,
and verify using readelf that your output is correct).
If invoked on an ELF file, examine should initialize a global file descriptor variable  for this file,
and leave the file open.
When invoked on a non-ELF file, or the file cannot be opened or mapped at all, you should print an error message, 
unmap the file (if already mapped) close the file (if already open), and set the respective file descriptor variable to -1 to 
indicate no valid file. You probably also should use a global variable to indicate the memory location of the mapped file.
</p>
<p>Your Examine ELF File should be able to handle up to two ELF files, keep both open and mapped at the same time.
So you should keep 2 separate file descriptors, map_start variables, and other relavant informatopn for each file.
That is, each time this function is called it should get a new file name, open the file and map it, and print out
the above stated information, while keeping any previous file information as well. Calling the function for the 3rd time or more you
may print out an error message and do nothing, or (bonus) you may decide to support more than 2 ELF files.</p>

<p>
You can test your code on the following 
file: <a href="https://moodle.bgu.ac.il/moodle/mod/resource/view.php?id=2378996">a.out</a>, and also any of the files
in the "ELF object file examples" folder.</p>

<h2 id="part_1_-_sections">Part 1 - Sections</h2>
Extend your myELF program from Part 0 to allow printing of all the Section names 
in an 32-bit ELF file (like <code class="code">readelf -S</code>). That is, implement the "Print Section Names" option.
<p></p><p>
For each ELF file already opened by Examine ELF File, Print Section Names should visit all 
section headers in the section header table, and for each one print its index, name,  address, offset, size in bytes, and type number.
Note that this is done for all files currently mapped, so if there is no file
just print an error message and return.
</p><p>
The format for each ELF file should be:
</p><pre class="code">File ELF-file-name
[index] section_name section_address section_offset section_size  section_type
[index] section_name section_address section_offset section_size  section_type
[index] section_name section_address section_offset section_size  section_type

....
</pre>

<p></p><p>
Verify your output is correct by comparing it to the output of <i>readelf</i>. For full credit the "section type" should be symbolic as per
readelf output, and should be implemented using a lookup into an array of (number, type-name) pairs, or an array of type names, and <b>not</b> a long
"if-else" statements.
In debug mode you should also print the value of the important indices and offsets, such as shstrndx and the section name offsets.
</p><p>
You can test your code on the following 
file: <a href="https://moodle.bgu.ac.il/moodle/mod/resource/view.php?id=2378996">a.out</a>, and also any of the files
in the "ELF object file examples" folder.</p><p>
</p><div class="tip"><b>Hints</b><br>
Global information about the ELF file is in the ELF header, including location and size of important tables. 
The size and name of the sections appear in the section header table. Recall that the actual name <b>strings</b> 
are stored in an appropriate <b>section</b> (.shstrtab for section names), and not in the section header!
<p></p><p>
</p></div>

<h2 id="part_2_-_symbols">Part 2 - Symbols</h2>
Extend your myELF program from part 1 to support an option that displays information on all the symbol names in a 32-bit ELF file. <p>
The new Print Symbols option, for each open ELF file, should visit all the symbols in that ELF file 
(if none, print an error message and return).
For each symbol, print its index number, its name and the name of 
the section in which it is defined. (similar to <code class="code">readelf -s</code>). Format should be:
</p><p>
</p><pre class="code">File ELF-file0name

[index] value section_index section_name symbol_name 
[index] value section_index section_name symbol_name
[index] value section_index section_name symbol_name

...
</pre>

<p></p><p>
Verify your output is correct by comparing it to the output of <i>readelf</i>.
In debug mode you should first print the size of each symbol table, the number of symbols therein, and
any other useful information.
</p><p>
</p><h4>Hints:</h4> 
<p>
Symbols are listed in the designated sections. The section in which a symbol is 
defined (if it is defined) is the index of the symbol, which is an index into the section header table, 
referring to the section header of the appropriate section, and from there the section name can be 
retrieved as above. Symbol name is an attribute of the symbol structure, but recall 
again that the actual name string is stored in a string table, a separate section(.strtab).
</p>

<h2 id="part_3_-_linker_pass_1">Part 3 - Linker pass I</h2>

<p>
In this part you shall write a limited version of a linker pass 1 (as mentioned in the last lecture). 
It will merge 2 ELF files (the ones opened by Examine ELF File) into one relocateable object file.
In this part, you should be using as input the files from the
the "ELF object file examples" folder, where "F1a.o", F1b.o", and "F1c.o" are intended for use as the first file,
and "F2a.o", "F2b.o" are intended for use as the second file. Merging files should result
in a single relocatable object file, mimicking the one generated by pass I of the linker.
For example, invoking pass I of the linker: "ld -r -m elf_i386 F1a.o F2a.o -o F12a.ro" generates
the relocatable object file "F12a.ro". Your program should generate the same type of output ELF file given
these same files.
The linker can be used on (only) the resulting file to create
a working executable file: "ld -m elf_i386 F12a.ro -o F12a" generates the "F12a" executable file that can actually be run.
<br>
</p>

<h2>Part 3.1: Check Files for Merge</h2>
<p>
Implement Check Files for Merge: CheckMerge. The CheckMerge function first checks that 2 ELF files have been opened and mapped,
(print an error message and return otherwise). 
Here we assume that there are exactly 2 such ELF files, and each file contains exactly one symbol table (otherwise, 
print "feature not supported" and return).
CheckMerge then, for each ELF file, loops over all symbols (except for symbol number 0, which is a dummy symbol) in its symbol table SYMTAB1 
(except for the first symbol, which is a dummy null symbol) and for each symbol sym:</p>
<ul>
<li> If sym is UNDEFINED, search for sym in SYMTAB2, the symbol table of the other ELF file. 
If not found in SYMTAB2, or found in SYMTAB2 but UNDEFINED there as well, print an error message: "Symbol sym undefined".
</li><li> If sym is defined, i.e. has a valid section number, again search for sym in SYMTAB2. In this case, if sym is found in SYMTAB2 amd
is defined, print an error message: "Symbol sym multiply defined".
</li></ul>
<p>Continue scanning symbols even after errors were found. Note that using "F1a.o" and "F2a.o" should result in no errors,
but using "F1b.o" and "F2b.o" should result in errors.</p>


<h2>Part 3.2: Merge ELF Files</h2>

<p>Note: in this semester, this entire part 3.2 is a bonus assignment, not required for a full grade.</p>

<p>In a real linkage editor, this is done only if checking for merge passes with no errors. 
However, your implementation will allow this even if the previous step found errors.
Here you should write a Merge function, which does the following:</p>

<ul>
<li> Create a new ELF file called "out.ro".
</li><li> Create an ELF header for this file and write it into the file "out.ro".
</li><li> Create a new section header table for this file.
</li><li> Create merged sections.
</li><li> Write the merged sections and the new section header table into the file "out.ro".
</li><li> Close the file "out.ro". (You may or may not need to update the ELF header before you close the file,
depending on your implementation.)
</li></ul>

<p>To implement the above, you should follow the procedure stated for pass I in the lecture. However, below are some
simplifying assumptions and restrictions that should make implementation easier. So you may assume all the following restrictions:</p>

<ul>
<li> There are exactly 2 ELF files being merged.
</li><li> The second ELF file does not contain any sections that do not exist in the first ELF file.
</li><li> The second ELF file does not contain any symbola that do not exist in the first ELF file.
</li><li> The second ELF file does mot have any relocations. 
</li></ul>

<p>With all the above symplifying assumptions, the following method can be used for merging.</p>

<ul>
<li> Use a copy of the ELF header of the first file as the ELF header for the merged file. 
You need to modify only the "e_shoff" field, as specified below.
</li><li> Use a copy of the section header table of the first ELF file as an initial version of the section header table for the merged file.
You will need to modify the "sh_off" and "sh_size" fields in each section header, as specified below.
</li><li> Mergable sections: ".text" ".data", ".rodata" sre merged as follows. Concatenate the section contents from the first ELF file and
the section contents from the second ELF file, to create the merged appropriate section. E.g. to create the merged ".text" section,
copy the contents of ".text" from the first ELF file, and to that append the contents of ".text" from the second ELF file.
The merged section obviously has a size that is the sum of the sizes (should accordingly change the appropriate section header).
</li><li> Section ".shstrtab" of the first ELF file can be used without changes as the ".shstrtab" of the merged file,
and the same for ".symtab" and any relocation sections (because of the restricting assumptions above).
</li><li> The symbola table of the first ELF file can be used as that of the merged file, after copying over symbol values and
definition of symbols from the second ELF file, for every symbol that is UNDEFINED in the first ELF file.
</li></ul>

<p>A practical implementation of the above then looks as follows:</p>

<ul>
<li> Create "out.ro" and copy an initial version of the ELF header as its header.
</li><li> Create (in memory) an initial version of the section header table for the merged file by copying that of the first ELF file.
</li><li> Loop over the entries of the new section header table, and process each section according to the above
scheme (concatenate ".text", copy ".shstrtab" as-is, etc.), and immediately write (append) the appropriate merged section
to "out.ro". Note that to concatenate e.g. ".text", simply write the contents of ".text"  from the first ELF file,
at the end of "out.ro", then find the contents of ".text" in the second ELF file (by finding ".text" in its section header table)
and write it again at the end of "out.ro" (no need to merge them in memory!)
So now you know the file offset of the merged section and its length, so update the appropriate
section header table entry fields (offset and size).
</li><li> Write the merged (and modified) section header table entry, appended to the end of "out.ro".
</li><li> Fix the "e_shoff" field in ELF header of "out.ro" to point to the location where you actually wrote the section header
table, and close "out.ro".
</li></ul>

<p>The basic requirement here is that "readelf" on "out.ro" will show that all sections have been merged
as stated above, and that the symbols have been resolved, when operating on pairs of ELF files that obey the restrictions
stated above. For a (double) bonus, running ld (the linker pass II) on "out.ro" should work correctly in these cases, and generate an
executable file that runs correctly!</p>

<h3 id="deliverables"> Deliverables:</h3>  

<p>You need to submit "myELF.c" and a makefile which compiles and links your code. Your code should incoporate all features from parts 0, 1, 2, 3
(except possibly for part 3.2 which is a bonus part) as a single program supporting all the features.</p>
</body></html>