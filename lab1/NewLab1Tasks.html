
<!-- saved from url=(0104)https://moodle.bgu.ac.il/moodle/pluginfile.php/4400658/mod_resource/content/13/NewLab1Tasks.html?embed=1 -->
<html data-darkreader-mode="dynamic" data-darkreader-scheme="dark"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><style class="darkreader darkreader--fallback" media="screen"></style><style class="darkreader darkreader--text" media="screen"></style><style class="darkreader darkreader--invert" media="screen">.jfk-bubble.gtx-bubble, .captcheck_answer_label > input + img, span#closed_text > img[src^="https://www.gstatic.com/images/branding/googlelogo"], span[data-href^="https://www.hcaptcha.com/"] > #icon, ::-webkit-calendar-picker-indicator, img.Wirisformula {
    filter: invert(100%) hue-rotate(180deg) contrast(90%) !important;
}</style><style class="darkreader darkreader--inline" media="screen">[data-darkreader-inline-bgcolor] {
  background-color: var(--darkreader-inline-bgcolor) !important;
}
[data-darkreader-inline-bgimage] {
  background-image: var(--darkreader-inline-bgimage) !important;
}
[data-darkreader-inline-border] {
  border-color: var(--darkreader-inline-border) !important;
}
[data-darkreader-inline-border-bottom] {
  border-bottom-color: var(--darkreader-inline-border-bottom) !important;
}
[data-darkreader-inline-border-left] {
  border-left-color: var(--darkreader-inline-border-left) !important;
}
[data-darkreader-inline-border-right] {
  border-right-color: var(--darkreader-inline-border-right) !important;
}
[data-darkreader-inline-border-top] {
  border-top-color: var(--darkreader-inline-border-top) !important;
}
[data-darkreader-inline-boxshadow] {
  box-shadow: var(--darkreader-inline-boxshadow) !important;
}
[data-darkreader-inline-color] {
  color: var(--darkreader-inline-color) !important;
}
[data-darkreader-inline-fill] {
  fill: var(--darkreader-inline-fill) !important;
}
[data-darkreader-inline-stroke] {
  stroke: var(--darkreader-inline-stroke) !important;
}
[data-darkreader-inline-outline] {
  outline-color: var(--darkreader-inline-outline) !important;
}
[data-darkreader-inline-stopcolor] {
  stop-color: var(--darkreader-inline-stopcolor) !important;
}
[data-darkreader-inline-bg] {
  background: var(--darkreader-inline-bg) !important;
}
[data-darkreader-inline-invert] {
    filter: invert(100%) hue-rotate(180deg);
}</style><style class="darkreader darkreader--variables" media="screen">:root {
   --darkreader-neutral-background: #131516;
   --darkreader-neutral-text: #d8d4cf;
   --darkreader-selection-background: #004daa;
   --darkreader-selection-text: #e8e6e3;
}</style><style class="darkreader darkreader--root-vars" media="screen"></style><style class="darkreader darkreader--user-agent" media="screen">@layer {
html {
    background-color: #181a1b !important;
}
html {
    color-scheme: dark !important;
}
iframe {
    color-scheme: initial;
}
html, body {
    background-color: #181a1b;
}
html, body {
    border-color: #736b5e;
    color: #e8e6e3;
}
a {
    color: #3391ff;
}
table {
    border-color: #545b5e;
}
mark {
    color: #e8e6e3;
}
::placeholder {
    color: #b2aba1;
}
input:-webkit-autofill,
textarea:-webkit-autofill,
select:-webkit-autofill {
    background-color: #404400 !important;
    color: #e8e6e3 !important;
}
::-webkit-scrollbar {
    background-color: #202324;
    color: #aba499;
}
::-webkit-scrollbar-thumb {
    background-color: #454a4d;
}
::-webkit-scrollbar-thumb:hover {
    background-color: #575e62;
}
::-webkit-scrollbar-thumb:active {
    background-color: #484e51;
}
::-webkit-scrollbar-corner {
    background-color: #181a1b;
}
::selection {
    background-color: #004daa !important;
    color: #e8e6e3 !important;
}
::-moz-selection {
    background-color: #004daa !important;
    color: #e8e6e3 !important;
}
}</style><meta name="darkreader" content="b3a8c644b56a4c80854692c48ef6b953"><style class="darkreader darkreader--override" media="screen">.vimvixen-hint {
    background-color: #7b5300 !important;
    border-color: #d8b013 !important;
    color: #f3e8c8 !important;
}
#vimvixen-console-frame {
    color-scheme: light !important;
}
::placeholder {
    opacity: 0.5 !important;
}
#edge-translate-panel-body,
.MuiTypography-body1,
.nfe-quote-text {
    color: var(--darkreader-neutral-text) !important;
}
gr-main-header {
    background-color: #0f3a48 !important;
}
.tou-z65h9k,
.tou-mignzq,
.tou-1b6i2ox,
.tou-lnqlqk {
    background-color: var(--darkreader-neutral-background) !important;
}
.tou-75mvi {
    background-color: #032029 !important;
}
.tou-ta9e87,
.tou-1w3fhi0,
.tou-1b8t2us,
.tou-py7lfi,
.tou-1lpmd9d,
.tou-1frrtv8,
.tou-17ezmgn {
    background-color: #0a0a0a !important;
}
.tou-uknfeu {
    background-color: #231603 !important;
}
.tou-6i3zyv {
    background-color: #19576c !important;
}
div.mermaid-viewer-control-panel .btn {
    background-color: var(--darkreader-neutral-background);
    fill: var(--darkreader-neutral-text);
}
svg g rect.er {
    fill: var(--darkreader-neutral-background) !important;
}
svg g rect.er.entityBox {
    fill: var(--darkreader-neutral-background) !important;
}
svg g rect.er.attributeBoxOdd {
    fill: var(--darkreader-neutral-background) !important;
}
svg g rect.er.attributeBoxEven {
    fill: var(--darkreader-selection-background);
    fill-opacity: 0.8 !important;
}
svg rect.er.relationshipLabelBox {
    fill: var(--darkreader-neutral-background) !important;
}
svg g g.nodes rect,
svg g g.nodes polygon {
    fill: var(--darkreader-neutral-background) !important;
}
svg g rect.task {
    fill: var(--darkreader-selection-background) !important;
}
svg line.messageLine0,
svg line.messageLine1 {
    stroke: var(--darkreader-neutral-text) !important;
}
div.mermaid .actor {
    fill: var(--darkreader-neutral-background) !important;
}
.google-material-icons {
    font-family: 'Google Material Icons' !important;
}
.google-symbols {
    font-family: 'Google Symbols Subset', 'Google Symbols' !important;
}
.material-icons-extended {
    font-family: 'Material Icons Extended' !important;
}
mitid-authenticators-code-app > .code-app-container {
    background-color: white !important;
    padding-top: 1rem;
}
iframe#unpaywall[src$="unpaywall.html"] {
    color-scheme: light !important;
}
.oui-icon {
    font-family: 'Oui Icons' !important;
}</style></head><body>

<h1>Physical Participation Lab 1</h1>
<h1>Program Memory and Pointers, Debugging and Simulating Object Oriented Programming</h1>

<p>
<b>Lab goals</b>: 
</p><ul>
<li> C primer
</li><li> Understanding storage addresses, introduction to pointers
</li><li> Pointers to basic data types, to structures, and to functions
</li><li> Simulating object-like behavior in C
</li></ul>

<b> Remark : All the files mentioned in the lab text below are available on the course Moodle page.</b>
<p>
</p><h1>(This lab is to be done SOLO)</h1>

   <h2>Task 0: Using <tt>gdb(1)</tt> to debug segmentation fault</h2>
    <p><i>You should finish this task <b>before</b> attending the lab session.</i></p>

    <p>C is a low-level language. Execution of a buggy C program may
    cause its abnormal termination due to <i>segmentation fault</i> ---
    illegal access to a memory address. Debugging segmentation faults can
    be a laborious task. GNU Debugger, is a powerful tool for program debugging and
    inspection. When a program is compiled for debugging and run inside
    gdb, the exact location of segmentation fault can be determined. In
    addition, the state of the processor registers and values of the
    variables at the time of the fault can be examined.</p>
    <p>The source code for a buggy program, <tt>count-words</tt>, is
    provided in file count-words.c. (You can find the file in the course Moodle) The program works
    correctly most of the time, but when called with a single word on the
    command line, terminates due to segmentation fault.</p>

    <ol>
      <li>Write a Makefile for the program.</li>
      <li><b>Specify compiler flags appropriate for debugging using</b> <tt>gdb</tt>.</li>
      <li>Find the location and the cause of the segmentation fault using <tt>gdb</tt>.</li>
      <li>Fix the bug and make sure the program works correctly.</li>

    </ol>
 <hr><b>The tasks below are to be done only during the lab session! Any code written before the lab will not be accepted.</b><warn title="The tasks below are to be done only during the lab session! Any code written before the lab will not be accepted.">
</warn>
<h2>Task 1: Understanding memory addresses and pointers</h2>
    <p>Logical virtual memory layout of a process is fixed in Linux. One can guess from the numerical
    value of a memory address whether the address points to:</p>
    <ul>
      <li>a static or a global variable,</li>
      <li>a local variable or a function argument,</li>
      <li>a function.</li>
    </ul>


<h3>T1a - Addresses</h3>

<p>Read, compile and run the addresses.c (You can find the file in the course Moodle) program (<b>remember to use the <i>-m32</i> flag</b>).<br>
Can you tell the location (stack, code, etc.) of each memory address?<br>
What can you say about the numerical values? Do they obey a particular order?<br>
<br>
Check <b>long</b> data size on your machine using <i>sizeof</i> operator. Is <i>long integer</i> data type enough for <b>dist</b> (address difference) variables ?  
</p>

<h3> T1b - Arrays memory layout </h3>

In this task we will examine the memory layout of arrays.
<br>
Define four arrays of length 3 as shown below <i>in the function main</i> and print the memory address of each array cell.
<br><code lang="cpp" numbers="false">
<br>int iarray[3];
<br>float farray[3];
<br>double darray[3];
<br>char carray[3];

</code><br><br>

Print the hexadecimal values of <b> iarray, iarray+1, farray, farray+1, darray, darray+1, carray and carray+1</b> (the values of these pointers, <b>not</b> the values pointed by the pointers). What can you say about the behavior of the '+' operator?
 <br><br>Given the results, explain to the TA the memory layout of arrays.
 
<h3>T1c - Distances</h3>
Understand and explain to the TA the purpose of the distances printed in the point_at function.
<br>
Where is each memory address allocated and what does it have to do with the printed distance?


Given the results, explain to the TA the memory layout of arrays.<br>

<h3> T1d - Pointers and arrays </h3>Array names are essentially pointer constants. Instead of using the arrays, use the pointers below to access array cells.
<br><code lang="cpp" numbers="false">
int iarray2[] = {1,2,3};
<br>char carray2[] = {'a','b','c'};
<br>int* iarray2Ptr;
<br>char* carray2Ptr;
</code><br><br>
Initialize the pointers iarrayPtr and carrayPtr to point to the first cell of the arrays iarray and carray respectively. Use the two pointers (iarrayPtr,carrayPtr) to print all the values of the two arrays.
<br><br>
Add an uninitialized pointer local variable p, and print its value (not the value it points to). What did you observe?

<h3>T1e - Address of command-line arguments</h3>

<p>Add a prinout of the address and content of the command line arguments (argv, argv[0], argv[1], etc.),
and run the program with some command-line arguments.
What can you say about the memory location of the command-line arguments visible in main( )?


</p><h2>Task 2 - Structs and pointers to functions</h2>Let us recall the following definition:<ul><li><b>Pointers to functions</b>
 - C allows declaring pointers to functions. The syntax is: <code>function_return_type (*pointer_name)(arguments_list);</code>  for simple types of return value and arguments. You can read more about pointers to functions <a href="http://en.wikibooks.org/wiki/C_Programming/Pointers_and_arrays#Pointers_to_Functions">here</a>.</li>
</ul><br>The  base.c (You can find the file in the course Moodle) file is the base file for task 2 - you should complete it as stated in the sub tasks.
<br><br>
<b> During Task 2 we read individual characters (bytes) from stdin using fgetc( )</b>


<ul>
<li>Please read the Deliverables section before continuing.</li>
</ul>



<h3>T2a </h3>Implement the map function that receives a pointer to a char (a pointer to a char array), an integer, and a pointer to a function. Map returns a new array (after allocating space for it), such that each value in the new array is the result of applying the function f on the corresponding character in the input array.
<ul>1. char* map(char *array, int array_length, char (*f) (char))</ul>
<br>Example:
<br><br>
<code>
    char arr1[] = {'H','E','Y','!'};
    <br>char* arr2 = map(arr1, 4, xoprt);
    <br>printf("%s\n", arr2);
    <br>free(arr2);
</code>
<br><br>
Results:
<code>
<br>
<br>48 110
<br>65 145
<br>79 171
<br>21 041
</code>
<ul><li>
    Do not forget to free allocated memory.
</li></ul>



<h3>T2b</h3>
Implement the following functions, and test them:
<br><br>
<code lang="cpp" numbers="false">
    char my_get(char c); 
    <br>/* Ignores c, reads and returns a character from stdin using fgetc. */
    <br><br>char cprt(char c); 
    <br>/* If c is a number between 0x20 and 0x7E, cprt prints the character of ASCII value c followed by a new line. Otherwise, cprt prints the dot ('.') character. After printing, cprt returns 
the value of c unchanged. */
    <br><br>char encrypt(char c); 
    <br>/* Gets a char c.  If c is between 0x20 and 0x4E add 0x20 to its value and return it. Otherwise return c unchanged */
    <br><br>char decrypt(char c); 
    <br>/* Gets a char c and returns its decrypted form subtractng 0x20 from its value. But if c was not between 0x40 and 0x7E it is returned unchanged */
    <br><br>char xoprt(char c); 
    <br>/* xoprt prints the value of c in a hexadecimal representation, then in octal representation, followed by a new line, and returns c unchanged. */
</code><br><br>
Note that array length is constant i.e. if the initial array is of length 5, then the new array that we receive with my_get function is of the same length.
<br><br>
Example: 
<br><code lang="cpp" numbers="false">
<br>int base_len = 5;
<br>char arr1[base_len];
<br>char* arr2 = map(arr1, base_len, my_get);
<br>char* arr3 = map(arr2, base_len, cprt);
<br>char* arr4 = map(arr3, base_len, xoprt);
<br>char* arr5 = map(arr4, base_len, encrypt);
<br>free(arr2);
<br>free(arr3);
<br>free(arr4);
<br>free(arr5);
</code>
<br>Result:
<br>
<code numbers="false">
<br>Hey! // this is the user input.
<br>H
<br>e
<br>y
<br>!
<br>.
<br>48 110
<br>65 145
<br>79 171
<br>21 041
<br>.
</code>

<ul>
  <li>Do not forget to free allocated memory.</li>
  <li>There is no need to encrypt letters in a cyclic manner, simply add 1.</li>
</ul>

<h3>Task 3 - Menu</h3><ul>

In this task we will be simulating objects in C. We will have a menu consisting of menu "objects",
each of which has a name to be printed on the menu, and a "method" (which you will implement using a pointer to
a function as a part of a "struct", as there are no "methods" or "objects" in C).

<b> From here on we read complete lines from stdin (using fgets( ) )instead of individual chars. </b> <br><br>

<p>
<b>struct</b> -  A struct in the C programming language is a structured type that aggregates a fixed set of labeled items,
possibly of different types, into a single entity similar to an "object".
</p><p>
The struct size equals the sum of the sizes of its objects plus alignment (if needed). You can get the size by using the <b>sizeof</b>  operator as follows: sizeof(struct struct_name).
 

</p><h3>T3a - Preliminary: Main Menu Loop and Terminating upon EOF.</h3>
Write and check a program called "menu" that prints to stdout a line stating "Select operation from the following menu:",
reads an input line from stdin, and repeats forever unless it encounters an EOF condition for stdin. 
In the latter case, your program should exit normally.
<p>
Recall that typing 'Ctrl+D' in the console simulates an EOF condition for stdin.

</p><h3>T3b - Implementing the menu</h3>
In this task we will implement the menu.
The menu must offer options for all your functions (Get String, Print String (crpt), Print Hex (xprt), Encrypt and Decrypt). See also the file Task 3 Example.
<p>
A function pointer can be a field in a structure, thus several functions can be accessed through a single data structure or container.
<br><br>
An array of function descriptors, each represented by a structure holding the function name (or description) and a pointer to the function, can be used to implement a program menu. Using the following structure definition:
<br><br>
<code lang="cpp" numbers="false">
struct fun_desc {
  <br> char *name;
  <br> char (*fun)(char);
<br>};
</code>
<br><br>
Alternatively, you can define this as a "typedef".
<br><br>
Below is an example of declaration and initialization of a two-element array of "function descriptors":
<br><br>
<code numbers="false" lang="cpp">
    struct fun_desc menu[] = { { "hello", hello }, { "bye", bye }, { NULL, NULL } };
</code>
<br><br>
Extend your basic <tt>menu</tt> from T3a to offer the functions from task 2 in the following way:
</p><ol>
    <li>
       Define a pointer 'carray' to a char array of length 5, initialized to the empty string (how?).
    </li>
    <li>
        Defines an array of fun_desc and initializes it (in the declaration, not as program code within a 
		function) to the names and the pointers of the functions that you implemented in Task 2. 
		The last fun_desc in the array should contain a null pointer name and a null pointer to
		function (<b>the length of the array should not be kept explicitly after constructing it</b>).
    </li>
    <li>
        Displays a menu (as a numbered list) of names (or descriptions) of the functions contained in the array.
		The menu should be printed by looping over the menu item names from the fun_desc, <b>not</b> by printing a string (or strings) that contain a copy of the name.
    </li>
    <li>
        Displays a prompt asking the user to choose a function by its number in the menu, reads the number,
		and checks if it is within bounds. The bound should be pre-computed only <b>once</b>, and <b>before</b> 
		the loop where the prompt is printed. If the number is within bounds, "Within bounds" is printed, 
		otherwise "Not within bounds" is printed and the program exits gracefully.
    </li>
    <li>
        Evaluate the appropriate function over 'carray' (using map) according to the number entered 
		by the user. Note that you should call the function by using the function pointer in the array of structures, 
		and not by using "if" or "switch".
    </li>
    <li>
        After calling any menu function , let 'carray' point to the new array returned by map( ).
    </li>
    <li>
        A user should be able to terminate the program when asked for a choice, by signaling EOF using 'Ctrl+D' on an empty line.
    </li>
	
</ol><br> Task3 examples can be found in the course Moodle 

<br><br>
Is it possible to call a function at an invalid address in your version of the program?<br>

<p></p><p>

<b>Bonus item (0 points)</b> Add a menu item for "junk", where the pointer to function is
initialized to point to something that is not known function code, such as your fun_desc array. Compile and
run the modified program, and select the junk menu item. What do you observe? <br>

</p><h3>Optional Tasks </h3>
Some topics in this course can be challenging, particularly for beginners , The "Optional Tasks" section of the lab is meant
to encourage students to seek assistance from the TAs and to ensure you comprehend the parts do-at-home labs
(in this case Lab A and Lab B) 
with which we believe you may face difficulties. If you and the TA have free time during the lab, you may wish
to do the following tasks from these labs during lab 1.
<br><br>
<b>Makefile task(Optional 1, from Lab A) </b> 
<br><br>
<b>Correct detection of EOF (Optional 2, from Lab A)</b>
<br><br>
<b>Using Valgrind (Optional 3, from Lab B)</b> 
<br><br>

<h2>Deliverables</h2><p>

As for all labs, you should complete task 0 before the lab, and make sure you understand what you did. 
<br><br>During the lab, you should complete all tasks, 1, 2,  and 3. If you did not complete task 3 submit whatever
you did complete in the lab.
Your lab grade is determined and decided in most cases by your lab TA during the lab.
Still, you are required to submit your code at the end of the lab, and the grade may be adjusted
based on what you submit. For example, failure to quote code copied from elsewhere,
even a permitted source, or written by ChatGPT, could cause a reduced grade, or worse.

<br><br>The deliverables must be submitted until the end of the day.<br>
<br>You must submit source files for task3 (note that task3 includes the functions in task 2) in respective folders, 
and also a makefile that compiles them. The source files must be organized in the following tree structure (
where '+' represents a folder and '-' represents a file):<br>
+ task3<br>
&nbsp;&nbsp;&nbsp;- makefile<br>
&nbsp;&nbsp;&nbsp;- menu_map.c<br>

</p><h4> Submission instructions</h4>
<ul>
<li>
Create a zip file with the relevant files (only).
</li>
<li>
Upload zip file to the submission system.
</li>
<li>
Download the zip file from the submission system and extract its content to an empty folder.
</li>
<li>
Compile and test the code to make sure that it still works.
</li>
</ul>

</ul></body></html>