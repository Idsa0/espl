
<!-- saved from url=(0105)https://moodle.bgu.ac.il/moodle/pluginfile.php/4400702/mod_resource/content/5/LabDassignment.html?embed=1 -->
<html data-darkreader-mode="dynamic" data-darkreader-scheme="dark"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><style class="darkreader darkreader--fallback" media="screen"></style><style class="darkreader darkreader--text" media="screen"></style><style class="darkreader darkreader--invert" media="screen">.jfk-bubble.gtx-bubble, .captcheck_answer_label > input + img, span#closed_text > img[src^="https://www.gstatic.com/images/branding/googlelogo"], span[data-href^="https://www.hcaptcha.com/"] > #icon, ::-webkit-calendar-picker-indicator, img.Wirisformula {
    filter: invert(100%) hue-rotate(180deg) contrast(90%) !important;
}</style><style class="darkreader darkreader--inline" media="screen">[data-darkreader-inline-bgcolor] {
  background-color: var(--darkreader-inline-bgcolor) !important;
}
[data-darkreader-inline-bgimage] {
  background-image: var(--darkreader-inline-bgimage) !important;
}
[data-darkreader-inline-border] {
  border-color: var(--darkreader-inline-border) !important;
}
[data-darkreader-inline-border-bottom] {
  border-bottom-color: var(--darkreader-inline-border-bottom) !important;
}
[data-darkreader-inline-border-left] {
  border-left-color: var(--darkreader-inline-border-left) !important;
}
[data-darkreader-inline-border-right] {
  border-right-color: var(--darkreader-inline-border-right) !important;
}
[data-darkreader-inline-border-top] {
  border-top-color: var(--darkreader-inline-border-top) !important;
}
[data-darkreader-inline-boxshadow] {
  box-shadow: var(--darkreader-inline-boxshadow) !important;
}
[data-darkreader-inline-color] {
  color: var(--darkreader-inline-color) !important;
}
[data-darkreader-inline-fill] {
  fill: var(--darkreader-inline-fill) !important;
}
[data-darkreader-inline-stroke] {
  stroke: var(--darkreader-inline-stroke) !important;
}
[data-darkreader-inline-outline] {
  outline-color: var(--darkreader-inline-outline) !important;
}
[data-darkreader-inline-stopcolor] {
  stop-color: var(--darkreader-inline-stopcolor) !important;
}
[data-darkreader-inline-bg] {
  background: var(--darkreader-inline-bg) !important;
}
[data-darkreader-inline-invert] {
    filter: invert(100%) hue-rotate(180deg);
}</style><style class="darkreader darkreader--variables" media="screen">:root {
   --darkreader-neutral-background: #131516;
   --darkreader-neutral-text: #d8d4cf;
   --darkreader-selection-background: #004daa;
   --darkreader-selection-text: #e8e6e3;
}</style><style class="darkreader darkreader--root-vars" media="screen"></style><style class="darkreader darkreader--user-agent" media="screen">@layer {
html {
    background-color: #181a1b !important;
}
html {
    color-scheme: dark !important;
}
iframe {
    color-scheme: initial;
}
html, body {
    background-color: #181a1b;
}
html, body {
    border-color: #736b5e;
    color: #e8e6e3;
}
a {
    color: #3391ff;
}
table {
    border-color: #545b5e;
}
mark {
    color: #e8e6e3;
}
::placeholder {
    color: #b2aba1;
}
input:-webkit-autofill,
textarea:-webkit-autofill,
select:-webkit-autofill {
    background-color: #404400 !important;
    color: #e8e6e3 !important;
}
::-webkit-scrollbar {
    background-color: #202324;
    color: #aba499;
}
::-webkit-scrollbar-thumb {
    background-color: #454a4d;
}
::-webkit-scrollbar-thumb:hover {
    background-color: #575e62;
}
::-webkit-scrollbar-thumb:active {
    background-color: #484e51;
}
::-webkit-scrollbar-corner {
    background-color: #181a1b;
}
::selection {
    background-color: #004daa !important;
    color: #e8e6e3 !important;
}
::-moz-selection {
    background-color: #004daa !important;
    color: #e8e6e3 !important;
}
}</style><meta name="darkreader" content="8642e9970baf4bb68ea07753648b5d16"><style class="darkreader darkreader--override" media="screen">.vimvixen-hint {
    background-color: #7b5300 !important;
    border-color: #d8b013 !important;
    color: #f3e8c8 !important;
}
#vimvixen-console-frame {
    color-scheme: light !important;
}
::placeholder {
    opacity: 0.5 !important;
}
#edge-translate-panel-body,
.MuiTypography-body1,
.nfe-quote-text {
    color: var(--darkreader-neutral-text) !important;
}
gr-main-header {
    background-color: #0f3a48 !important;
}
.tou-z65h9k,
.tou-mignzq,
.tou-1b6i2ox,
.tou-lnqlqk {
    background-color: var(--darkreader-neutral-background) !important;
}
.tou-75mvi {
    background-color: #032029 !important;
}
.tou-ta9e87,
.tou-1w3fhi0,
.tou-1b8t2us,
.tou-py7lfi,
.tou-1lpmd9d,
.tou-1frrtv8,
.tou-17ezmgn {
    background-color: #0a0a0a !important;
}
.tou-uknfeu {
    background-color: #231603 !important;
}
.tou-6i3zyv {
    background-color: #19576c !important;
}
div.mermaid-viewer-control-panel .btn {
    background-color: var(--darkreader-neutral-background);
    fill: var(--darkreader-neutral-text);
}
svg g rect.er {
    fill: var(--darkreader-neutral-background) !important;
}
svg g rect.er.entityBox {
    fill: var(--darkreader-neutral-background) !important;
}
svg g rect.er.attributeBoxOdd {
    fill: var(--darkreader-neutral-background) !important;
}
svg g rect.er.attributeBoxEven {
    fill: var(--darkreader-selection-background);
    fill-opacity: 0.8 !important;
}
svg rect.er.relationshipLabelBox {
    fill: var(--darkreader-neutral-background) !important;
}
svg g g.nodes rect,
svg g g.nodes polygon {
    fill: var(--darkreader-neutral-background) !important;
}
svg g rect.task {
    fill: var(--darkreader-selection-background) !important;
}
svg line.messageLine0,
svg line.messageLine1 {
    stroke: var(--darkreader-neutral-text) !important;
}
div.mermaid .actor {
    fill: var(--darkreader-neutral-background) !important;
}
.google-material-icons {
    font-family: 'Google Material Icons' !important;
}
.google-symbols {
    font-family: 'Google Symbols Subset', 'Google Symbols' !important;
}
.material-icons-extended {
    font-family: 'Material Icons Extended' !important;
}
mitid-authenticators-code-app > .code-app-container {
    background-color: white !important;
    padding-top: 1rem;
}
iframe#unpaywall[src$="unpaywall.html"] {
    color-scheme: light !important;
}
.oui-icon {
    font-family: 'Oui Icons' !important;
}</style></head><body><h1>Lab D: Assembly Language "do at home" lab.</h1>

<h3>Lab Goals</h3>
<ul>
    <li>Assembly language primer: improving proficiency in assembly language features.</li>
	<li>Interfacing C to assembly code-continued
	</li><li>Using dynamically allocated memory</li>
	<li>Multi-precision addition.</li>
    <li>Pseudo-random number generation.</li>
 </ul>

<h1>This lab may be done in pairs!</h1>

<tip title="">
As usual, you should read and understand the reading material and complete part 0 before attempting to do
the lab assignment. <br>
For this lab, unlike the previous lab (lab 3) you <b>are</b> supposed to use stdlib functions.
Make sure you compile and link with the CDECL conventions,
as otherwise the C to assembly interface you have used before will not work!
</tip>


<h2>Part 0: Basic Command-line Arguments Printing using stdlib</h2>

<b>Part 0 is crucial for the successful completion of this lab! make sure you finish it and understand it before implementing
your program to be submitted.</b>
<br>
Read the Assembly lecture <a href="https://moodle.bgu.ac.il/moodle/mod/resource/view.php?id=2299524">Assembly Language Primer</a>.
For this task you must understand the arguments of main( ), how to access the arguments of a function in assembly language (discussed in class),
and how to pass arguments to a function in the C CDECL calling convention. Be careful not to mess up your stack!

<p>
In this preliminary you need to write function starting with the (global) label "main" in assembly language which performs the following:
</p><ul>
    <li>print <b>argc</b> in decimal format to stdout using printf</li>
    <li>print <b>argv[i]</b> to stdout using puts, for all i from 0 to argc-1</li>
</ul>
<p></p>

Now, write a makefile to compile the assembly code you wrote, and to link the resulting object file with te C standart library (gcc myfile.o). 
This makefile will be useful throughout the lab.


<h1>The lab assignment: Multi-Precision Integer IO and Adder</h1>

<p>We have partitioned the lab work into parts, suggesting the order of implementation
and testing. Nevertheless, you are supposed to submit a single program that
ties it all together as statesd in part 4 below.</p>


<h2>Part 1: Structs and Multi-precision Integer Hexadecimal Printing and Reading</h2>
Read about the difference between little endian and big endian <a href="https://en.wikipedia.org/wiki/Endianness">little vs. big endian</a>.
<br>

<h3>Part 1.A: Printing a Multi-precision Integer</h3>
<p>
    Implement print_multi(struct multi *p)): gets a pointer to struct multi{unsigned char size; unsigned char num [ ]}
    where size is the number of bytes in the num array (always greater than 0), and the num array is a multi-precision unsigned 
	integer in <b>little endian</b>.
    The function should print the value of the <b>entire</b> number in hexadecimal by calling printf("%02hhx") once for every
	word in the array. If the number contains leading zeros, you may wish to remove them in the output,
	but this is not a requirement in the assignment.
    <br>
    <b>Warning: please note that C library functions do not maintain the value of all your registers!</b>
</p>
<br>
Test this by initializing a global struct, as in the following lines, and call print_multi from main with a pointer to the struct
x_struct:
<dt>  x_struct:  dw  5</dt>
<dt>  x_num:     dw 0xaa, 1,2,0x44,0x4f</dt>

<p>The output in this case should be (with a linefeed at the end):</p>
<pre>4f440201aa
</pre>

<h3>Part 1.B: Reading  a Multi-precision Integer</h3>
<p>
After you implement and test the printing, you should implement a function getmulti that reads a line from stdin using fgets,
containing only a sequence of hexadecimal digits, and stores it in the above type of structure. 
You may assume that the input contains no leading zeros.
Use your printing function to see that your input is correct. You may assume that the input line
contains less than 600 characters. Note that your code will be simpler if you process hexadecimal characters in <b>pairs</b>.</p>

<p>Think: how do you <b>very simply</b> make sure you always need to process an even number of hex digits? </p>

<h2>Part 2: Addition of Multi-Precision integers</h2>
<h4>Overview</h4>
In this task you need to implement the function <b>struct multi* add_multi(struct multi *p, *q)</b>;
<br>
The function should perform an addition between two such numbers represented as structs, creating a third number represented the same way.
This is done by byte-wise addition between the two arrays defined in the given structs while maintaining the carry between additions.
The result should be placed in a newly allocated array in
a new allocated struct of size 1+max(len1, len2).
<p>
    Input: <br>
    Two arrays <b>array1, array2</b> (defined as "variables" in the code), of size <b>len1, len2</b> respectively.
    <br>
    For example:
    </p><dt>  x_struct:  dw  5</dt>
    <dt>  x_num:     dw 0xaa, 1,2,0x44,0x4f
    <br>
    </dt><dt>  y_struct:  dw  6</dt>
    <dt>  y_num:     dw 0xaa, 1,2,3,0x44,0x4f</dt>
<p></p>
<p>
    Output: <br>
    Without loss of generality, assume that len1 &gt; len2. Therefore
    </p><ul>
    <li><b>max_len = max(len1,len2)=len1</b></li>
    <li><b>min_len = min(len1,len2)=len2</b></li>
    </ul>
    The function will return an array, dynmically allocated using malloc, <b>result_array</b>, of size <b>max_len</b> such that:
    <ul>
        <li><b>result_array[i]=array1[i]+array2[i]+cy</b> for 0 &lt;= i &lt; min_len.</li>
        <li><b>result_array[i]=array1[i]+cy</b> for min_len &lt;= i &lt; max_len.</li>
    </ul>
	cy is the result of the carry from the previous addition.
<p></p>


<h3>Part 2.A: Get MaxMin</h3>

Implement this assembly language function <b>not</b> in the C calling convention.
Given pointers to number structures in eax and ebx, return the pointer to the one
with the higher length field in eax, and the other pointer in ebx.


<h3>Part 2.B: add_multi Implementation</h3>
Use the MaxMin function and Print_multi you wrote to implement and test the element-wise addition,
and print each number to be added and the result in separate lines to stdout.
<br>
<p>
   <b>Test your function by defining appropriate initialized number structs and printing the resulting array.</b>
</p>

<h2>Part 3: Pseudo-Random Number Generator (PRNG)</h2>

Implement a function name <b>rand_num</b> that uses basic assembly instructions in order to generate a random number using a "linear-feedback shift register".
See <a href="https://en.wikipedia.org/wiki/Linear-feedback_shift_register">LFSR in Wikipedia</a>
The function uses a global initialized (not to zero!) unsigned 16-bit (word) STATE variable, and a constant MASK variable.
Use the mask for the Fibonacci LFSR for 16 bits.
Each pseudo-random operation does:
<ul>
<li> Use the MASK to get just the relevant bits of the STATE variable.
</li><li> Compute the parity of the above relevant bits. Note: we recommend, but not require, that you use the parity flag!
</li><li> Shift the bits of the (non-maked) STATE variable one position to the right, with the MSB determined by the parity you just computed.
</li></ul>
<br>
First, test your function by printing some generated pseudo-random numbers in hexadecimal using printf.
Once you have done that, write a function PRmulti: uses the PRNG to create a pseudo-random Multi-precision Integer as follows:
the first 8 bits generated by the PRNG
determine the length n in bytes of the number (generate a new random byte instead if this is zero!),
and then 8*n PRNG bits determine the actual value to be insetred 
into the appropriate struct.
<br>
If done properly, you should be able to use your printing function from part 1.A to print the resulting numbers,
do so and thoroughly test your code.

<h2>Part 4: Putting it all together</h2>

<p>
Your final program "multi" should combine all the above as follows. The program should print
to stdout the numbers to be added (in hexadecimal), and then their sum. Then the program exists normally.
The source of the numbers is to
be determined as follows:
</p><ul>
<li> By default (no command-line arguments), the program operates (i.e. prints and adds) on the numbers encoded by x_struct and
y_struct.</li>
<li> If argv[1] is "-I", the program operates on numbers obtained from stdin, one number per line (as in part 1.B)</li>
<li> If argv[1] is "-R" the program operates on numbers obtained from the Pseudo-Random number generator, as in part 3.</li>
</ul>

<p>Some example of program runs follow. First, the default with no command line arguments:</p>

<pre>$ ./multi
4f440201aa
4f44030201aa
4f9347040354
</pre>

<p>
In the examples with the "-I" flag below, the first two lines are input lines.
You  may have an extra leading zero in each number's output.</p>

<pre>$ ./multi -I
fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
1
fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
1
100000000000000000000000000000000000000000000000000000000000000000000000
$ ./multi -I
2
1
2
1
3
</pre>


<p>When running with "-R" flag, the result may vary depending on the seed and how the 16-bit pseudo-random is used exactly,
and the numbers may be very long, as in the following example:</p>
<pre>$ ./multi -R
5588c47a8814c200cf54a8e1dc23036edd0b196e7d5a8510c1698fdeba56294dd970a69c59249962913d80e3bde487a991057c8a1d15d26e45a6ecb0303c480a19c61360f0eac2c039db49a247b74ac3a0be451ecc8d7f1378196e
7f933c689717b3b90785688ffe379eb82f8faecb679a4bebaa78018761582c968fb622e3bdf4414d5934d765abe8b3597cc218ae337dbaee915580733f71b66af6c0f19a83baa6842885a8f1922439bbeeb1d848e25d2768070d039ee84b539a83aa6060e0b4031e24d9588cd7d52c56e11cd58c8f9e908d27d027304cb1d85824b9ef59ace2b563897c6afe77b4632112508b8db7ca9717a37fe34d5924118163d918b6ca3f79990a194ef092147297b7e22579395b85304ca11ebcec8844b61a1fd454b0189ee074f591c59ac3189e7851e3bd6c645b759d29fdc6ebe2f55994963f319c
7f933c689717b3b90785688ffe379eb82f8faecb679a4bebaa78018761582c968fb622e3bdf4414d5934d765abe8b3597cc218ae337dbaee915580733f71b66af6c0f19a83baa6842885a8f1922439bbeeb1d848e25d2768070d039ee84b539a83aa6060e0b4031e24d9588cd7d52c56e11cd58c8f9e908d27d027304cb1d85824b9ef59ace2b563897cc0873c2eeb35d4515ae260ac733aa6eec05872928edbe8e9da205a1e33ef3367286138b0cbbc5144b6b6ba3f4314d44aafc2691261cbec8e19fb9cc8cf1cbcffab8bae2409893b121d98b606a32ce7ed9e853101c1e713a9b74b0a
</pre>




<h2> Submission </h2>

<p>
You need to submit a single assembly language code file, "multi.s", and a makefile which compiles it
and links it into an executable named "multi".
(Compile: "nasm -f elf32 multi.s -o multi.o" Link: "gcc -m32 multi.o -o multi")
The code is as completed in part 4, which as stated above contains all the
other parts.

You are required to submit a zip file in the format [your_id].zip that contains "multi.s" and "makefile".
</p></body></html>